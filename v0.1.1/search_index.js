var documenterSearchIndex = {"docs":
[{"location":"contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Feel free to open issues or pull requests to the official repository. Ideas, tips, bug reports, or contributions are all welcome.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for ComputableDAGs.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for documentation of everything else.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [ComputableDAGs]\nPages   = [\"ComputableDAGs.jl\"]\nOrder   = [:module]","category":"page"},{"location":"lib/public/#ComputableDAGs.ComputableDAGs","page":"Public","title":"ComputableDAGs.ComputableDAGs","text":"ComputableDAGs\n\nA module containing tools to represent computations as DAGs.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 2","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/internals/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/internals/utility/#Helper-Functions","page":"Utility","title":"Helper Functions","text":"","category":"section"},{"location":"lib/internals/utility/","page":"Utility","title":"Utility","text":"Modules = [ComputableDAGs]\nPages   = [\"utils.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/internals/utility/#ComputableDAGs._lt_node_tuples-Tuple{Tuple{Node, Int64}, Tuple{Node, Int64}}","page":"Utility","title":"ComputableDAGs._lt_node_tuples","text":"_lt_node_tuples(n1::Tuple{Node, Int}, n2::Tuple{Node, Int})\n\nLess-Than comparison between nodes with indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs._lt_nodes-Tuple{Node, Node}","page":"Utility","title":"ComputableDAGs._lt_nodes","text":"_lt_nodes(n1::Node, n2::Node)\n\nLess-Than comparison between nodes. Uses the nodes' ids to sort.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.bytes_to_human_readable-Tuple{Any}","page":"Utility","title":"ComputableDAGs.bytes_to_human_readable","text":"bytes_to_human_readable(bytes)\n\nReturn a human readable string representation of the given number.\n\njulia> using ComputableDAGs\n\njulia> ComputableDAGs.bytes_to_human_readable(4096)\n\"4.0 KiB\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.mem-Tuple{DAG}","page":"Utility","title":"ComputableDAGs.mem","text":"mem(graph::DAG)\n\nReturn the memory footprint of the graph in Byte. Should be the same result as Base.summarysize(graph) but a lot faster.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.mem-Tuple{Node}","page":"Utility","title":"ComputableDAGs.mem","text":"mem(op::Operation)\n\nReturn the memory footprint of the node in Byte. Used in mem(graph::DAG). Unlike Base.summarysize() this doesn't follow all references which would yield (almost) the size of the entire graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.mem-Tuple{Operation}","page":"Utility","title":"ComputableDAGs.mem","text":"mem(op::Operation)\n\nReturn the memory footprint of the operation in Byte. Used in mem(graph::DAG). Unlike Base.summarysize() this doesn't follow all references which would yield (almost) the size of the entire graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.noop-Tuple{}","page":"Utility","title":"ComputableDAGs.noop","text":"noop()\n\nFunction with no arguments, returns nothing, does nothing. Useful for noop FunctionCalls.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.sort_node!-Tuple{Node}","page":"Utility","title":"ComputableDAGs.sort_node!","text":"sort_node!(node::Node)\n\nSort the nodes' parents and children vectors. The vectors are mostly very short so sorting does not take a lot of time. Sorted nodes are required to make the finding of NodeReductions a lot faster using the NodeTrie data structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.unpack_identity-Tuple{StaticArraysCore.SVector{1}}","page":"Utility","title":"ComputableDAGs.unpack_identity","text":"unpack_identity(x::SVector)\n\nFunction taking an SVector, returning it unpacked.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.unroll_symbol_vector-Tuple{Vector}","page":"Utility","title":"ComputableDAGs.unroll_symbol_vector","text":"unroll_symbol_vector(vec::Vector{Symbol})\n\nReturn the given vector as single String without quotation marks or brackets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Trie-Helper","page":"Utility","title":"Trie Helper","text":"","category":"section"},{"location":"lib/internals/utility/","page":"Utility","title":"Utility","text":"This is a simple implementation of a Trie Data Structure to greatly improve the performance of the Node Reduction search.","category":"page"},{"location":"lib/internals/utility/","page":"Utility","title":"Utility","text":"Modules = [ComputableDAGs]\nPages   = [\"trie.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/internals/utility/#ComputableDAGs.NodeIdTrie","page":"Utility","title":"ComputableDAGs.NodeIdTrie","text":"NodeIdTrie\n\nHelper struct for NodeTrie. After the Trie's first level, every Trie level contains the vector of nodes that had children up to that level, and the TrieNode's children by UUID of the node's children.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/utility/#ComputableDAGs.NodeIdTrie-Union{Tuple{}, Tuple{NodeType}} where NodeType<:Node","page":"Utility","title":"ComputableDAGs.NodeIdTrie","text":"NodeIdTrie()\n\nConstructor for an empty NodeIdTrie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.NodeTrie","page":"Utility","title":"ComputableDAGs.NodeTrie","text":"NodeTrie\n\nTrie data structure for node reduction, inserts nodes by children. Assumes that given nodes have ordered vectors of children (see sort_node!). First insertion level is the node's own task type and thus does not have a value (every node has a task type).\n\nSee also: insert! and collect\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/utility/#ComputableDAGs.NodeTrie-Tuple{}","page":"Utility","title":"ComputableDAGs.NodeTrie","text":"NodeTrie()\n\nConstructor for an empty NodeTrie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Base.collect-Tuple{ComputableDAGs.NodeTrie}","page":"Utility","title":"Base.collect","text":"collect(trie::NodeTrie)\n\nReturn all sets of at least 2 Nodes that have accumulated in leaves of the trie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Base.insert!-Union{Tuple{NodeType}, Tuple{TaskType}, Tuple{ComputableDAGs.NodeTrie, NodeType}} where {TaskType<:AbstractDataTask, NodeType<:DataTaskNode{TaskType}}","page":"Utility","title":"Base.insert!","text":"insert!(trie::NodeTrie, node::Node)\n\nInsert the given node into the trie. It's sorted by its type in the first layer, then by its children in the following layers.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.collect_helper-Tuple{ComputableDAGs.NodeIdTrie, Set{Vector{Node}}}","page":"Utility","title":"ComputableDAGs.collect_helper","text":"collect_helper(trie::NodeIdTrie, acc::Set{Vector{Node}})\n\nCollects the Vectors of this NodeIdTrie node and all its children and puts them in the acc argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.insert_helper!-Union{Tuple{NodeType}, Tuple{TaskType}, Tuple{ComputableDAGs.NodeIdTrie{NodeType}, NodeType, Int64}} where {TaskType<:AbstractDataTask, NodeType<:DataTaskNode{TaskType}}","page":"Utility","title":"ComputableDAGs.insert_helper!","text":"insert_helper!(trie::NodeIdTrie, node::Node, depth::Int)\n\nInsert the given node into the trie. The depth is used to iterate through the trie layers, while the function calls itself recursively until it ran through all children of the node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#Code-Generation","page":"Code Generation","title":"Code Generation","text":"","category":"section"},{"location":"lib/internals/code_gen/#Types","page":"Code Generation","title":"Types","text":"","category":"section"},{"location":"lib/internals/code_gen/","page":"Code Generation","title":"Code Generation","text":"Modules = [ComputableDAGs]\nPages = [\"code_gen/type.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"lib/internals/code_gen/#ComputableDAGs.Tape","page":"Code Generation","title":"ComputableDAGs.Tape","text":"Tape{INPUT}\n\nTODO: update docs\n\nINPUT the input type of the problem instance\ncode::Vector{Expr}: The julia expression containing the code for the whole graph.\ninputSymbols::Dict{String, Vector{Symbol}}: A dictionary of symbols mapping the names of the input nodes of the graph to the symbols their inputs should be provided on.\noutputSymbol::Symbol: The symbol of the final calculated value\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/code_gen/#Function-Generation","page":"Code Generation","title":"Function Generation","text":"","category":"section"},{"location":"lib/internals/code_gen/","page":"Code Generation","title":"Code Generation","text":"Implementations for generation of a callable function. A function generated this way cannot immediately be called. One Julia World Age has to pass before this is possible, which happens when the global Julia scope advances. If the DAG and therefore the generated function becomes too large, use the tape machine instead, since compiling large functions becomes infeasible.","category":"page"},{"location":"lib/internals/code_gen/","page":"Code Generation","title":"Code Generation","text":"Modules = [ComputableDAGs]\nPages = [\"code_gen/function.jl\"]\nOrder = [:function]","category":"page"},{"location":"lib/internals/code_gen/#ComputableDAGs.execute-Tuple{DAG, Any, Machine, Any, Module}","page":"Code Generation","title":"ComputableDAGs.execute","text":"execute(\n    graph::DAG,\n    instance,\n    machine::Machine,\n    input,\n    context_module::Module\n)\n\nExecute the code of the given graph on the given input values.\n\nThis is essentially shorthand for\n\ntape = gen_tape(graph, instance, machine, context_module)\nreturn execute_tape(tape, input)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.get_compute_function-Tuple{DAG, Any, Machine, Module}","page":"Code Generation","title":"ComputableDAGs.get_compute_function","text":"get_compute_function(\n    graph::DAG,\n    instance,\n    machine::Machine,\n    context_module::Module\n)\n\nReturn a function of signature compute_<id>(input::input_type(instance)), which will return the result of the DAG computation on the given input. The final argument context_module should always be @__MODULE__ to be able to use functions defined in the caller's environment. For this to work, you need \n\nusing RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(@__MODULE__)\n\nin your top level.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#Tape-Machine","page":"Code Generation","title":"Tape Machine","text":"","category":"section"},{"location":"lib/internals/code_gen/","page":"Code Generation","title":"Code Generation","text":"Modules = [ComputableDAGs]\nPages = [\"code_gen/tape_machine.jl\"]\nOrder = [:function]","category":"page"},{"location":"lib/internals/code_gen/#ComputableDAGs.call_fc-Union{Tuple{M}, Tuple{VectorT}, Tuple{ComputableDAGs.FunctionCall{VectorT, M}, Dict{Symbol, Any}}} where {VectorT, M}","page":"Code Generation","title":"ComputableDAGs.call_fc","text":"call_fc(fc::FunctionCall, cache::Dict{Symbol, Any})\n\nExecute the given FunctionCall on the dictionary.\n\nSeveral more specialized versions of this function exist to reduce vector unrolling work for common cases.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.execute_tape-Tuple{ComputableDAGs.Tape, Any}","page":"Code Generation","title":"ComputableDAGs.execute_tape","text":"execute_tape(tape::Tape, input::Input) where {Input}\n\nExecute the given tape with the given input.\n\nFor implementation reasons, this disregards the set CacheStrategy of the devices and always uses a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.expr_from_fc-Union{Tuple{ComputableDAGs.FunctionCall{VectorT, M}}, Tuple{M}, Tuple{VectorT}} where {VectorT, M}","page":"Code Generation","title":"ComputableDAGs.expr_from_fc","text":"expr_from_fc(fc::FunctionCall)\n\nFor a given function call, return an expression evaluating it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_cache_init_code-Tuple{Machine}","page":"Code Generation","title":"ComputableDAGs.gen_cache_init_code","text":"gen_cache_init_code(machine::Machine)\n\nFor each AbstractDevice in the given Machine, returning a Vector{Expr} doing the initialization.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_input_assignment_code-Tuple{Dict{String, Vector{Symbol}}, Any, Machine, Module}","page":"Code Generation","title":"ComputableDAGs.gen_input_assignment_code","text":"gen_input_assignment_code(\n    input_symbols::Dict{String, Vector{Symbol}},\n    instance::AbstractProblemInstance,\n    machine::Machine,\n    context_module::Module\n)\n\nReturn a Vector{Expr} doing the input assignments from the given problem_input onto the input_symbols.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_tape","page":"Code Generation","title":"ComputableDAGs.gen_tape","text":"gen_tape(\n    graph::DAG,\n    instance::AbstractProblemInstance,\n    machine::Machine,\n    context_module::Module,\n    scheduler::AbstractScheduler = GreedyScheduler()\n)\n\nGenerate the code for a given graph. The return value is a Tape.\n\nSee also: execute, execute_tape\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#Task","page":"Task","title":"Task","text":"","category":"section"},{"location":"lib/internals/task/#Type","page":"Task","title":"Type","text":"","category":"section"},{"location":"lib/internals/task/","page":"Task","title":"Task","text":"Modules = [ComputableDAGs]\nPages = [\"task/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/task/#ComputableDAGs.AbstractComputeTask","page":"Task","title":"ComputableDAGs.AbstractComputeTask","text":"AbstractComputeTask <: AbstractTask\n\nThe shared base type for any compute task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.AbstractDataTask","page":"Task","title":"ComputableDAGs.AbstractDataTask","text":"AbstractDataTask <: AbstractTask\n\nThe shared base type for any data task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.AbstractTask","page":"Task","title":"ComputableDAGs.AbstractTask","text":"AbstractTask\n\nThe shared base type for any task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.DataTask","page":"Task","title":"ComputableDAGs.DataTask","text":"DataTask <: AbstractDataTask\n\nTask representing a specific data transfer.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#Create","page":"Task","title":"Create","text":"","category":"section"},{"location":"lib/internals/task/","page":"Task","title":"Task","text":"Modules = [ComputableDAGs]\nPages = [\"task/create.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/task/#Base.copy-Tuple{AbstractComputeTask}","page":"Task","title":"Base.copy","text":"copy(t::AbstractComputeTask)\n\nReturn a copy of the given compute task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.copy-Tuple{AbstractDataTask}","page":"Task","title":"Base.copy","text":"copy(t::AbstractDataTask)\n\nFallback implementation of the copy of an abstract data task, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Compare","page":"Task","title":"Compare","text":"","category":"section"},{"location":"lib/internals/task/","page":"Task","title":"Task","text":"Modules = [ComputableDAGs]\nPages = [\"task/compare.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractComputeTask, AbstractComputeTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractComputeTask, t2::AbstractComputeTask)\n\nEquality comparison between two compute tasks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractDataTask, AbstractDataTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractDataTask, t2::AbstractDataTask)\n\nEquality comparison between two data tasks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractTask, AbstractTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractTask, t2::AbstractTask)\n\nFallback implementation of equality comparison between two abstract tasks. Always returns false. For equal specific types of t1 and t2, a more specific comparison is called instead, doing an actual comparison.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Compute","page":"Task","title":"Compute","text":"","category":"section"},{"location":"lib/internals/task/","page":"Task","title":"Task","text":"Modules = [ComputableDAGs]\nPages = [\"task/compute.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/task/#ComputableDAGs.get_function_call-Union{Tuple{CompTask}, Tuple{CompTask, ComputableDAGs.AbstractDevice, AbstractVector, Symbol}} where CompTask<:AbstractComputeTask","page":"Task","title":"ComputableDAGs.get_function_call","text":"get_function_call(n::Node)\nget_function_call(t::AbstractTask, device::AbstractDevice, in_symbols::AbstractVector, out_symbol::Symbol)\n\nFor a node or a task together with necessary information, return a vector of FunctionCalls for the computation of the node or task.\n\nFor ordinary compute or data tasks the vector will contain exactly one element.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Properties","page":"Task","title":"Properties","text":"","category":"section"},{"location":"lib/internals/task/","page":"Task","title":"Task","text":"Modules = [ComputableDAGs]\nPages = [\"task/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/task/#Base.copy-Tuple{DataTask}","page":"Task","title":"Base.copy","text":"copy(t::DataTask)\n\nCopy the data task and return it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.children-Tuple{DataTask}","page":"Task","title":"ComputableDAGs.children","text":"children(::DataTask)\n\nReturn the number of children of a data task (always 1).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.compute","page":"Task","title":"ComputableDAGs.compute","text":"compute(t::AbstractTask; data...)\n\nFallback implementation of the compute function of a compute task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.compute_effort","page":"Task","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::AbstractTask)\n\nFallback implementation of the compute effort of a task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.compute_effort-Tuple{AbstractDataTask}","page":"Task","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::AbstractDataTask)\n\nReturn the compute effort of a data task, always zero, regardless of the specific task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.data","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractTask)\n\nFallback implementation of the data of a task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.data-Tuple{AbstractComputeTask}","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractComputeTask)\n\nReturn the data of a compute task, always zero, regardless of the specific task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.data-Tuple{AbstractDataTask}","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractDataTask)\n\nReturn the data of a data task. Given by the task's .data field.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/diff/#Diff","page":"Diff","title":"Diff","text":"","category":"section"},{"location":"lib/internals/diff/#Type","page":"Diff","title":"Type","text":"","category":"section"},{"location":"lib/internals/diff/","page":"Diff","title":"Diff","text":"Modules = [ComputableDAGs]\nPages = [\"diff/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/diff/#ComputableDAGs.Diff","page":"Diff","title":"ComputableDAGs.Diff","text":"Diff\n\nA named tuple representing a difference of added and removed nodes and edges on a DAG.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/diff/#Properties","page":"Diff","title":"Properties","text":"","category":"section"},{"location":"lib/internals/diff/","page":"Diff","title":"Diff","text":"Modules = [ComputableDAGs]\nPages = [\"diff/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/diff/#Base.length-Tuple{@NamedTuple{addedNodes::Vector{Node}, removedNodes::Vector{Node}, addedEdges::Vector{Edge}, removedEdges::Vector{Edge}, updatedChildren::Vector{Tuple{Node, AbstractTask}}}}","page":"Diff","title":"Base.length","text":"length(diff::Diff)\n\nReturn a named tuple of the lengths of the added/removed nodes/edges. The fields are .addedNodes, .addedEdges, .removedNodes and .removedEdges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/diff/#Printing","page":"Diff","title":"Printing","text":"","category":"section"},{"location":"lib/internals/diff/","page":"Diff","title":"Diff","text":"Modules = [ComputableDAGs]\nPages = [\"diff/print.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/diff/#Base.show-Tuple{IO, @NamedTuple{addedNodes::Vector{Node}, removedNodes::Vector{Node}, addedEdges::Vector{Edge}, removedEdges::Vector{Edge}, updatedChildren::Vector{Tuple{Node, AbstractTask}}}}","page":"Diff","title":"Base.show","text":"show(io::IO, diff::Diff)\n\nPretty-print a Diff. Called via print, println and co.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Node","page":"Node","title":"Node","text":"","category":"section"},{"location":"lib/internals/node/#Type","page":"Node","title":"Type","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/node/#ComputableDAGs.ComputeTaskNode","page":"Node","title":"ComputableDAGs.ComputeTaskNode","text":"ComputeTaskNode <: Node\n\nAny node that computes a result from inputs using an AbstractComputeTask.\n\nFields\n\n.task:            The node's compute task type. A concrete subtype of AbstractComputeTask.\n.parents:         A vector of the node's parents (i.e. nodes that depend on this one).\n.children:        A vector of tuples with the node's children (i.e. nodes that this one depends on) and their index, used to order the arguments for the AbstractComputeTask.\n.id:              The node's id. Improves the speed of comparisons and is used as a unique identifier.\n.nodeReduction:   Either this node's NodeReduction or missing, if none. There can only be at most one.\n.nodeSplit:       Either this node's NodeSplit or missing, if none. There can only be at most one.\n.device:          The Device this node has been scheduled on by a Scheduler.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.DataTaskNode","page":"Node","title":"ComputableDAGs.DataTaskNode","text":"DataTaskNode <: Node\n\nAny node that transfers data and does no computation.\n\nFields\n\n.task:            The node's data task type. Usually DataTask.\n.parents:         A vector of the node's parents (i.e. nodes that depend on this one).\n.children:        A vector of tuples of the node's children (i.e. nodes that this one depends on) and their indices, indicating their order in the resulting function call passed to the task.\n.id:              The node's id. Improves the speed of comparisons and is used as a unique identifier.\n.nodeReduction:   Either this node's NodeReduction or missing, if none. There can only be at most one.\n.nodeSplit:       Either this node's NodeSplit or missing, if none. There can only be at most one.\n.name:            The name of this node for entry nodes into the graph (is_entry_node) to reliably assign the inputs to the correct nodes when executing.\n\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.Edge","page":"Node","title":"ComputableDAGs.Edge","text":"Edge\n\nType of an edge in the graph. Edges can only exist between a DataTaskNode and a ComputeTaskNode or vice versa, not between two of the same type of node.\n\nAn edge always points from child to parent: child = e.edge[1] and parent = e.edge[2]. Additionally, the Edgecontains theindex` which is used as the child's index in the parent node.\n\nThe child is the prerequisite node of the parent.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.Node","page":"Node","title":"ComputableDAGs.Node","text":"Node\n\nThe abstract base type of every node.\n\nSee DataTaskNode, ComputeTaskNode and make_node.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#Create","page":"Node","title":"Create","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/create.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/node/#ComputableDAGs.make_edge","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::Node, n2::Node, index::Int)\n\nFallback implementation of make_edge throwing an error. If you got this error it likely means you tried to construct an edge between two nodes of the same type.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_edge-2","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::DataTaskNode, n2::ComputeTaskNode)\n\nConstruct and return a new Edge pointing from n1 (child) to n2 (parent).\n\nThe index parameter is 0 by default and is passed to the parent node as argument index for its child.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_edge-3","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::ComputeTaskNode, n2::DataTaskNode, index::Int)\n\nConstruct and return a new Edge pointing from n1 (child) to n2 (parent).\n\nThe index parameter is 0 by default and is passed to the parent node as argument index for its child.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_node","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractDataTask)\n\nConstruct and return a new DataTaskNode with the given task.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_node-Tuple{AbstractComputeTask}","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractComputeTask)\n\nConstruct and return a new ComputeTaskNode with the given task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.make_node-Tuple{AbstractTask}","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractTask)\n\nFallback implementation of make_node for an AbstractTask, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Compare","page":"Node","title":"Compare","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/compare.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/node/#Base.:==-Tuple{Edge, Edge}","page":"Node","title":"Base.:==","text":"==(e1::Edge, e2::Edge)\n\nEquality comparison between two edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Tuple{Node, Node}","page":"Node","title":"Base.:==","text":"==(n1::Node, n2::Node)\n\nFallback equality comparison between two nodes. For equal node types, the more specific versions of this function will be called.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Union{Tuple{TaskType}, Tuple{ComputeTaskNode{TaskType}, ComputeTaskNode{TaskType}}} where TaskType<:AbstractComputeTask","page":"Node","title":"Base.:==","text":"==(n1::ComputeTaskNode, n2::ComputeTaskNode)\n\nEquality comparison between two ComputeTaskNodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Union{Tuple{TaskType}, Tuple{DataTaskNode{TaskType}, DataTaskNode{TaskType}}} where TaskType<:AbstractDataTask","page":"Node","title":"Base.:==","text":"==(n1::DataTaskNode, n2::DataTaskNode)\n\nEquality comparison between two DataTaskNodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Properties","page":"Node","title":"Properties","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/node/#ComputableDAGs.children-Tuple{DataTaskNode}","page":"Node","title":"ComputableDAGs.children","text":"children(node::Node)\n\nReturn node's children.\n\nA node's children are its prerequisite nodes, nodes that need to execute before the task of this node.\n\nA node's children are the nodes that must run before it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_child-Tuple{Node, Node}","page":"Node","title":"ComputableDAGs.is_child","text":"is_child(potential_child::Node, node::Node)\n\nReturn whether the potential_child is a child of node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_entry_node-Tuple{Node}","page":"Node","title":"ComputableDAGs.is_entry_node","text":"is_entry_node(node::Node)\n\nReturn whether this node is an entry node in its graph, i.e., it has no children.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_exit_node-Tuple{Node}","page":"Node","title":"ComputableDAGs.is_exit_node","text":"is_exit_node(node::Node)\n\nReturn whether this node is an exit node of its graph, i.e., it has no parents.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_parent-Tuple{Node, Node}","page":"Node","title":"ComputableDAGs.is_parent","text":"is_parent(potential_parent::Node, node::Node)\n\nReturn whether the potential_parent is a parent of node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.parents-Tuple{DataTaskNode}","page":"Node","title":"ComputableDAGs.parents","text":"parents(node::Node)\n\nReturn the node's parents.\n\nA node's parents are its subsequent nodes, nodes that need this node to execute.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.partners-Tuple{Node, Set{Node}}","page":"Node","title":"ComputableDAGs.partners","text":"partners(node::Node, set::Set{Node})\n\nAlternative version to partners(node::Node), avoiding allocation of a new set. Works on the given set and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.partners-Tuple{Node}","page":"Node","title":"ComputableDAGs.partners","text":"partners(node::Node)\n\nReturn a vector of all partners of this node. \n\nA node's partners are all parents of any of its children. The result contains no duplicates and includes the node itself.\n\nnote: Note\nThis is very slow when there are multiple children with many parents.  This is less of a problem in siblings(node::Node) because (depending on the model) there are no nodes with a large number of children, or only a single one.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.siblings-Tuple{Node}","page":"Node","title":"ComputableDAGs.siblings","text":"siblings(node::Node)\n\nReturn a vector of all siblings of this node. \n\nA node's siblings are all children of any of its parents. The result contains no duplicates and includes the node itself.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.task-Union{Tuple{DataTaskNode{TaskType}}, Tuple{TaskType}} where TaskType<:Union{AbstractComputeTask, AbstractDataTask}","page":"Node","title":"ComputableDAGs.task","text":"task(node::Node)\n\nReturn the node's task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Print","page":"Node","title":"Print","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/print.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/node/#Base.show-Tuple{IO, Edge}","page":"Node","title":"Base.show","text":"show(io::IO, e::Edge)\n\nPrint a short string representation of the edge to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.show-Tuple{IO, Node}","page":"Node","title":"Base.show","text":"show(io::IO, n::Node)\n\nPrint a short string representation of the node to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.to_var_name-Tuple{Base.UUID}","page":"Node","title":"ComputableDAGs.to_var_name","text":"to_var_name(id::UUID)\n\nReturn the uuid as a string usable as a variable name in code generation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Validate","page":"Node","title":"Validate","text":"","category":"section"},{"location":"lib/internals/node/","page":"Node","title":"Node","text":"Modules = [ComputableDAGs]\nPages = [\"node/validate.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/node/#ComputableDAGs.is_valid-Tuple{DAG, ComputeTaskNode}","page":"Node","title":"ComputableDAGs.is_valid","text":"is_valid(graph::DAG, node::ComputeTaskNode)\n\nVerify that the given compute node is valid in the graph. Call with @assert or @test when testing or debugging.\n\nThis also calls is_valid_node(graph::DAG, node::Node).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_valid-Tuple{DAG, DataTaskNode}","page":"Node","title":"ComputableDAGs.is_valid","text":"is_valid(graph::DAG, node::DataTaskNode)\n\nVerify that the given compute node is valid in the graph. Call with @assert or @test when testing or debugging.\n\nThis also calls is_valid_node(graph::DAG, node::Node).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_valid_node-Tuple{DAG, Node}","page":"Node","title":"ComputableDAGs.is_valid_node","text":"is_valid_node(graph::DAG, node::Node)\n\nVerify that a given node is valid in the graph. Call like @test is_valid_node(g, n). Uses @assert to fail if something is invalid but also provide an error message.\n\nThis function is very performance intensive and should only be used when testing or debugging.\n\nSee also this function's specific versions for the concrete Node types is_valid(graph::DAG, node::ComputeTaskNode) and is_valid(graph::DAG, node::DataTaskNode).\n\n\n\n\n\n","category":"method"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Application-repositories","page":"Manual","title":"Application repositories","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following repositories use this package productively, which can be referred to as examples:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"QEDFeynman: Compute differential cross-sections of scattering processes in ABC and QED models.","category":"page"},{"location":"manual/#Jupyter-Notebooks","page":"Manual","title":"Jupyter Notebooks","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the notebooks directory are notebooks containing some examples of the usage of this repository.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"TBW","category":"page"},{"location":"lib/internals/properties/#Properties","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"lib/internals/properties/#Type","page":"Properties","title":"Type","text":"","category":"section"},{"location":"lib/internals/properties/","page":"Properties","title":"Properties","text":"Modules = [ComputableDAGs]\nPages = [\"properties/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/properties/#ComputableDAGs.GraphProperties","page":"Properties","title":"ComputableDAGs.GraphProperties","text":"GraphProperties\n\nRepresentation of a DAG's properties.\n\nFields:\n\n.data: The total data transfer.\n.computeEffort: The total compute effort.\n.computeIntensity: The compute intensity, will always equal .computeEffort / .data.\n.noNodes: Number of Nodes.\n.noEdges: Number of Edges.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/properties/#Create","page":"Properties","title":"Create","text":"","category":"section"},{"location":"lib/internals/properties/","page":"Properties","title":"Properties","text":"Modules = [ComputableDAGs]\nPages = [\"properties/create.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/properties/#Utility","page":"Properties","title":"Utility","text":"","category":"section"},{"location":"lib/internals/properties/","page":"Properties","title":"Properties","text":"Modules = [ComputableDAGs]\nPages = [\"properties/utility.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/properties/#Base.:+-Tuple{@NamedTuple{data::Float64, computeEffort::Float64, computeIntensity::Float64, noNodes::Int64, noEdges::Int64}, @NamedTuple{data::Float64, computeEffort::Float64, computeIntensity::Float64, noNodes::Int64, noEdges::Int64}}","page":"Properties","title":"Base.:+","text":"+(prop1::GraphProperties, prop2::GraphProperties)\n\nAdd prop1 and prop2 and return the result as a new GraphProperties. Also take care to keep consistent compute intensity.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/properties/#Base.:--Tuple{@NamedTuple{data::Float64, computeEffort::Float64, computeIntensity::Float64, noNodes::Int64, noEdges::Int64}, @NamedTuple{data::Float64, computeEffort::Float64, computeIntensity::Float64, noNodes::Int64, noEdges::Int64}}","page":"Properties","title":"Base.:-","text":"-(prop1::GraphProperties, prop2::GraphProperties)\n\nSubtract prop1 from prop2 and return the result as a new GraphProperties. Also take care to keep consistent compute intensity.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/properties/#Base.:--Tuple{@NamedTuple{data::Float64, computeEffort::Float64, computeIntensity::Float64, noNodes::Int64, noEdges::Int64}}","page":"Properties","title":"Base.:-","text":"-(prop::GraphProperties)\n\nUnary negation of the graph properties. .computeIntensity will not be negated because .data and .computeEffort both are.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Operation","page":"Operation","title":"Operation","text":"","category":"section"},{"location":"lib/internals/operation/#Types","page":"Operation","title":"Types","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedNodeReduction","page":"Operation","title":"ComputableDAGs.AppliedNodeReduction","text":"AppliedNodeReduction <: AppliedOperation\n\nThe applied version of the NodeReduction.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedNodeSplit","page":"Operation","title":"ComputableDAGs.AppliedNodeSplit","text":"AppliedNodeSplit <: AppliedOperation\n\nThe applied version of the NodeSplit.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedOperation","page":"Operation","title":"ComputableDAGs.AppliedOperation","text":"AppliedOperation\n\nAn abstract base class for already applied operations. An applied operation can be reversed iff it is the last applied operation on the DAG. Every applied operation stores a Diff from when it was initially applied to be able to revert the operation.\n\nSee also: revert_operation!.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.NodeReduction","page":"Operation","title":"ComputableDAGs.NodeReduction","text":"NodeReduction <: Operation\n\nThe NodeReduction operation. Represents the reduction of two or more nodes with one another. Only one of the input nodes is kept, while all others are deleted and their parents are accumulated in the kept node's parents instead.\n\nAfter the node reduction is applied, the graph has length(nr.input) - 1 fewer nodes.\n\nRequirements for successful application\n\nA vector of nodes can be reduced if:\n\nAll nodes are in the graph.\nAll nodes have the same task type.\nAll nodes have the same set of children.\n\nis_valid_node_reduction_input can be used to @assert these requirements.\n\nSee also: can_reduce\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.NodeSplit","page":"Operation","title":"ComputableDAGs.NodeSplit","text":"NodeSplit <: Operation\n\nThe NodeSplit operation. Represents the split of its input node into one node for each of its parents. It is the reverse operation to the NodeReduction.\n\nRequirements for successful application\n\nA node can be split if:\n\nIt is in the graph.\nIt has at least 2 parents.\n\nis_valid_node_split_input can be used to @assert these requirements.\n\nSee also: can_split\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.Operation","page":"Operation","title":"ComputableDAGs.Operation","text":"Operation\n\nAn abstract base class for operations. An operation can be applied to a DAG, changing its nodes and edges.\n\nPossible operations on a DAG can be retrieved using get_operations.\n\nSee also: push_operation!, pop_operation!\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#Find","page":"Operation","title":"Find","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/find.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.generate_operations-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.generate_operations","text":"generate_operations(graph::DAG)\n\nGenerate all possible operations on the graph. Used initially when the graph is freshly assembled or parsed. Uses multithreading for speedup.\n\nSafely inserts all the found operations into the graph and its nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.insert_operation!-Tuple{NodeReduction}","page":"Operation","title":"ComputableDAGs.insert_operation!","text":"insert_operation!(nf::NodeReduction)\n\nInsert the given node reduction into its input nodes' operation caches. This is thread-safe.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.insert_operation!-Tuple{NodeSplit}","page":"Operation","title":"ComputableDAGs.insert_operation!","text":"insert_operation!(nf::NodeSplit)\n\nInsert the given node split into its input node's operation cache. This is thread-safe.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.nr_insertion!-Tuple{PossibleOperations, Vector{Vector{NodeReduction}}}","page":"Operation","title":"ComputableDAGs.nr_insertion!","text":"nr_insertion!(operations::PossibleOperations, nodeReductions::Vector{Vector{NodeReduction}})\n\nInsert the node reductions into the graph and the nodes' caches. Employs multithreading for speedup.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.ns_insertion!-Tuple{PossibleOperations, Vector{Vector{NodeSplit}}}","page":"Operation","title":"ComputableDAGs.ns_insertion!","text":"ns_insertion!(operations::PossibleOperations, nodeSplits::Vector{Vector{NodeSplits}})\n\nInsert the node splits into the graph and the nodes' caches. Employs multithreading for speedup.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Apply","page":"Operation","title":"Apply","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/apply.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.apply_all!-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.apply_all!","text":"apply_all!(graph::DAG)\n\nApply all unapplied operations in the DAG. Is automatically called in all functions that require the latest state of the DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, NodeReduction}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(graph::DAG, operation::NodeReduction)\n\nApply the given NodeReduction to the graph. Generic wrapper around node_reduction!.\n\nReturn an AppliedNodeReduction object generated from the graph's Diff.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, NodeSplit}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(graph::DAG, operation::NodeSplit)\n\nApply the given NodeSplit to the graph. Generic wrapper around node_split!.\n\nReturn an AppliedNodeSplit object generated from the graph's Diff.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, Operation}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(graph::DAG, operation::Operation)\n\nFallback implementation of apply_operation! for unimplemented operation types, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.node_reduction!-Tuple{DAG, Vector{Node}}","page":"Operation","title":"ComputableDAGs.node_reduction!","text":"node_reduction!(graph::DAG, nodes::Vector{Node})\n\nReduce the given nodes together into one node, return the applied difference to the graph.\n\nFor details see NodeReduction.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.node_split!-Union{Tuple{TaskType}, Tuple{DAG, Union{ComputeTaskNode{TaskType}, DataTaskNode{TaskType}}}} where TaskType<:AbstractTask","page":"Operation","title":"ComputableDAGs.node_split!","text":"node_split!(graph::DAG, n1::Node)\n\nSplit the given node into one node per parent, return the applied difference to the graph.\n\nFor details see NodeSplit.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_diff!-Tuple{DAG, @NamedTuple{addedNodes::Vector{Node}, removedNodes::Vector{Node}, addedEdges::Vector{Edge}, removedEdges::Vector{Edge}, updatedChildren::Vector{Tuple{Node, AbstractTask}}}}","page":"Operation","title":"ComputableDAGs.revert_diff!","text":"revert_diff!(graph::DAG, diff::Diff)\n\nRevert the given diff on the graph. Used to revert the individual AppliedOperations with revert_operation!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, AppliedOperation}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(graph::DAG, operation::AppliedOperation)\n\nFallback implementation of operation reversion for unimplemented operation types, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, ComputableDAGs.AppliedNodeReduction}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(graph::DAG, operation::AppliedNodeReduction)\n\nRevert the applied node reduction on the graph. Return the original NodeReduction operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, ComputableDAGs.AppliedNodeSplit}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(graph::DAG, operation::AppliedNodeSplit)\n\nRevert the applied node split on the graph. Return the original NodeSplit operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Get","page":"Operation","title":"Get","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/get.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.get_operations-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.get_operations","text":"get_operations(graph::DAG)\n\nReturn the PossibleOperations of the graph at the current state.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Clean","page":"Operation","title":"Clean","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/clean.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.clean_node!-Union{Tuple{TaskType}, Tuple{DAG, Union{ComputeTaskNode{TaskType}, DataTaskNode{TaskType}}}} where TaskType<:AbstractTask","page":"Operation","title":"ComputableDAGs.clean_node!","text":"clean_node!(graph::DAG, node::Node)\n\nSort this node's parent and child sets, then find reductions and splits involving it. Needs to be called after the node was changed in some way.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.find_reductions!-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.find_reductions!","text":"find_reductions!(graph::DAG, node::Node)\n\nFind node reductions involving the given node. The function pushes the found NodeReduction (if any) everywhere it needs to be and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.find_splits!-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.find_splits!","text":"find_splits!(graph::DAG, node::Node)\n\nFind the node split of the given node. The function pushes the found NodeSplit (if any) everywhere it needs to be and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Utility","page":"Operation","title":"Utility","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/utility.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#Base.:==-Tuple{NodeReduction, NodeReduction}","page":"Operation","title":"Base.:==","text":"==(op1::NodeReduction, op2::NodeReduction)\n\nEquality comparison between two node reductions. Two node reductions are considered equal when they have the same inputs.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.:==-Tuple{NodeSplit, NodeSplit}","page":"Operation","title":"Base.:==","text":"==(op1::NodeSplit, op2::NodeSplit)\n\nEquality comparison between two node splits. Two node splits are considered equal if they have the same input node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.:==-Tuple{Operation, Operation}","page":"Operation","title":"Base.:==","text":"==(op1::Operation, op2::Operation)\n\nFallback implementation of operation equality. Return false. Actual comparisons are done by the overloads of same type operation comparisons.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.delete!-Tuple{PossibleOperations, NodeReduction}","page":"Operation","title":"Base.delete!","text":"delete!(operations::PossibleOperations, op::NodeReduction)\n\nDelete the given node reduction from the possible operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.delete!-Tuple{PossibleOperations, NodeSplit}","page":"Operation","title":"Base.delete!","text":"delete!(operations::PossibleOperations, op::NodeSplit)\n\nDelete the given node split from the possible operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.isempty-Tuple{PossibleOperations}","page":"Operation","title":"Base.isempty","text":"isempty(operations::PossibleOperations)\n\nReturn whether operations is empty, i.e. all of its fields are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.length-Tuple{PossibleOperations}","page":"Operation","title":"Base.length","text":"length(operations::PossibleOperations)\n\nReturn a named tuple with the number of each of the operation types as a named tuple. The fields are named the same as the PossibleOperations'.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.can_reduce-Tuple{Node, Node}","page":"Operation","title":"ComputableDAGs.can_reduce","text":"can_reduce(n1::Node, n2::Node)\n\nReturn whether the given two nodes can be reduced. See NodeReduction for the requirements.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.can_split-Tuple{Node}","page":"Operation","title":"ComputableDAGs.can_split","text":"can_split(n1::Node)\n\nReturn whether the given node can be split. See NodeSplit for the requirements.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Print","page":"Operation","title":"Print","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/print.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, NodeReduction}","page":"Operation","title":"Base.show","text":"show(io::IO, op::NodeReduction)\n\nPrint a string representation of the node reduction to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, NodeSplit}","page":"Operation","title":"Base.show","text":"show(io::IO, op::NodeSplit)\n\nPrint a string representation of the node split to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, PossibleOperations}","page":"Operation","title":"Base.show","text":"show(io::IO, ops::PossibleOperations)\n\nPrint a string representation of the set of possible operations to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Validate","page":"Operation","title":"Validate","text":"","category":"section"},{"location":"lib/internals/operation/","page":"Operation","title":"Operation","text":"Modules = [ComputableDAGs]\nPages = [\"operation/validate.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid-Tuple{DAG, NodeReduction}","page":"Operation","title":"ComputableDAGs.is_valid","text":"is_valid(graph::DAG, nr::NodeReduction)\n\nAssert for a given NodeReduction whether it is a valid operation in the graph.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid-Tuple{DAG, NodeSplit}","page":"Operation","title":"ComputableDAGs.is_valid","text":"is_valid(graph::DAG, nr::NodeSplit)\n\nAssert for a given NodeSplit whether it is a valid operation in the graph.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid_node_reduction_input-Tuple{DAG, Vector{Node}}","page":"Operation","title":"ComputableDAGs.is_valid_node_reduction_input","text":"is_valid_node_reduction_input(graph::DAG, nodes::Vector{Node})\n\nAssert for a gven node reduction input whether the nodes can be reduced. For the requirements of a node reduction see NodeReduction.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid_node_split_input-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.is_valid_node_split_input","text":"is_valid_node_split_input(graph::DAG, n1::Node)\n\nAssert for a gven node split input whether the node can be split. For the requirements of a node split see NodeSplit.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"lib/internals/devices/#Interface","page":"Devices","title":"Interface","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/interface.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.AbstractDevice","page":"Devices","title":"ComputableDAGs.AbstractDevice","text":"AbstractDevice\n\nAbstract base type for every device, like GPUs, CPUs or any other compute devices. Every implementation needs to implement various functions and needs a member cacheStrategy.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.CacheStrategy","page":"Devices","title":"ComputableDAGs.CacheStrategy","text":"CacheStrategy\n\nAbstract base type for caching strategies.\n\nSee also: strategies\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.Dictionary","page":"Devices","title":"ComputableDAGs.Dictionary","text":"Dictionary <: CacheStrategy\n\nA caching strategy relying on a dictionary of Symbols to store every input and output.\n\nImplements the CacheStrategy interface.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.LocalVariables","page":"Devices","title":"ComputableDAGs.LocalVariables","text":"LocalVariables <: CacheStrategy\n\nA caching strategy relying solely on local variables for every input and output.\n\nImplements the CacheStrategy interface.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.Machine","page":"Devices","title":"ComputableDAGs.Machine","text":"Machine\n\nA representation of a machine to execute on. Contains information about its architecture (CPUs, GPUs, maybe more). This representation can be used to make a more accurate cost prediction of a DAG state.\n\nSee also: Scheduler\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.CACHE_STRATEGIES","page":"Devices","title":"ComputableDAGs.CACHE_STRATEGIES","text":"CACHE_STRATEGIES::Dict{Type{AbstractDevice}, Symbol}\n\nGlobal dictionary of available caching strategies per device. Each implementation of AbstractDevice should add its available strategies to the dictionary.\n\nSee also: strategies\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/devices/#ComputableDAGs.DEVICE_TYPES","page":"Devices","title":"ComputableDAGs.DEVICE_TYPES","text":"DEVICE_TYPES::Vector{Type}\n\nGlobal vector of available and implemented device types. Each implementation of a AbstractDevice should add its concrete type to this vector.\n\nSee also: device_types, get_devices\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/devices/#ComputableDAGs.default_strategy","page":"Devices","title":"ComputableDAGs.default_strategy","text":"default_strategy(deviceType::Type{T}) where {T <: AbstractDevice}\n\nInterface function that must be implemented for every subtype of AbstractDevice. Returns the default CacheStrategy to use on the given device type. See also: cache_strategy, set_cache_strategy\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.gen_access_expr","page":"Devices","title":"ComputableDAGs.gen_access_expr","text":"gen_access_expr(device::AbstractDevice, symbol::Symbol)\n\nInterface function that must be implemented for every subtype of AbstractDevice and at least one CacheStrategy. Return an Expr or QuoteNode accessing the variable identified by [symbol].\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.gen_cache_init_code","page":"Devices","title":"ComputableDAGs.gen_cache_init_code","text":"gen_cache_init_code(device::AbstractDevice)\n\nInterface function that must be implemented for every subtype of AbstractDevice and at least one CacheStrategy. Returns an Expr initializing this device's variable cache.\n\nThe strategy is a symbol\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.get_devices","page":"Devices","title":"ComputableDAGs.get_devices","text":"get_devices(t::Type{T}; verbose::Bool) where {T <: AbstractDevice}\n\nInterface function that must be implemented for every subtype of AbstractDevice. Returns a Vector{Type} of the devices for the given AbstractDevice Type available on the current machine.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.kernel","page":"Devices","title":"ComputableDAGs.kernel","text":"kernel(gpu_type::Type{<:AbstractGPU}, graph::DAG, instance)\n\nFor a GPU type, a DAG, and a problem instance, return an Expr containing a function of signature compute_<id>(input::<GPU>Vector, output::<GPU>Vector, n::Int64), which will return the result of the DAG computation of the input on the given output vector, intended for computation on GPUs. Currently, CUDAGPU and ROCmGPU are available if their respective package extensions are loaded.\n\nThe generated kernel function accepts its thread ID in only the x-dimension, and only as thread ID, not as block ID. The input and output should therefore be 1-dimensional vectors. For detailed information on GPU programming and the Julia packages, please refer to their respective documentations.\n\nA simple example call for a CUDA kernel might look like the following:\n\n@cuda threads = (32,) always_inline = true cuda_kernel!(cu_inputs, outputs, length(cu_inputs))\n\nnote: Note\nUnlike the standard get_compute_function to generate a callable function which returns a RuntimeGeneratedFunction, this returns an Expr that needs to be eval'd. This is a current limitation of RuntimeGeneratedFunctions.jl which currently cannot wrap GPU kernels. This might change in the future.\n\nSize limitation\n\nThe generated kernel does not use any internal parallelization, i.e., the DAG is compiled into a serialized function, processing each input in a single thread of the GPU. This means it can be heavily parallelized and use the GPU at 100% for sufficiently large input vectors (and assuming the function does not become IO limited etc.). However, it also means that there is a limit to how large the compiled function can be. If it gets too large, the compilation might fail, take too long to complete, the kernel might fail during execution if too much stack memory is required, or other similar problems. If this happens, your problem is likely too large to be compiled to a GPU kernel like this.\n\nCompute Requirements\n\nA GPU function has more restrictions on what can be computed than general functions running on the CPU. In Julia, there are mainly two important restrictions to consider: \n\nUsed data types must be stack allocatable, i.e., isbits(x) must be true for arguments and local variables used in ComputeTasks.\nFunction calls must not be dynamic. This means that type stability is required and the compiler must know in advance which method of a generic function to call. What this specifically entails may change with time and also differs between the different target GPU libraries. From experience, using the always_inline = true argument for @cuda calls can help with this.\n\nwarning: Warning\nThis feature is currently experimental. There are still some unresolved issues with the generated kernels.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.measure_device!","page":"Devices","title":"ComputableDAGs.measure_device!","text":"measure_device!(device::AbstractDevice; verbose::Bool)\n\nInterface function that must be implemented for every subtype of AbstractDevice. Measures the compute speed of the given device and writes into it.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#Detect","page":"Devices","title":"Detect","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/detect.jl\"]\nOrder = [:function]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.get_machine_info-Tuple{}","page":"Devices","title":"ComputableDAGs.get_machine_info","text":"get_machine_info(verbose::Bool)\n\nReturn the Machine currently running on. The parameter verbose defaults to true when interactive.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Measure","page":"Devices","title":"Measure","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/measure.jl\"]\nOrder = [:function]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.measure_devices!-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.measure_devices!","text":"measure_devices(machine::Machine; verbose::Bool)\n\nMeasure FLOPS, RAM, cache sizes and what other properties can be extracted for the devices in the given machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.measure_transfer_rates!-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.measure_transfer_rates!","text":"measure_transfer_rates(machine::Machine; verbose::Bool)\n\nMeasure the transfer rates between devices in the machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Implementations","page":"Devices","title":"Implementations","text":"","category":"section"},{"location":"lib/internals/devices/#General","page":"Devices","title":"General","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/impl.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.cache_strategy-Tuple{ComputableDAGs.AbstractDevice}","page":"Devices","title":"ComputableDAGs.cache_strategy","text":"cache_strategy(device::AbstractDevice)\n\nReturns the cache strategy set for this device.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.cpu_st-Tuple{}","page":"Devices","title":"ComputableDAGs.cpu_st","text":"cpu_st()\n\nA function returning a Machine that only has a single thread of one CPU. It is the simplest machine definition possible and produces a simple function when used with get_compute_function.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.device_types-Tuple{}","page":"Devices","title":"ComputableDAGs.device_types","text":"device_types()\n\nReturn a vector of available and implemented device types.\n\nSee also: DEVICE_TYPES\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.entry_device-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.entry_device","text":"entry_device(machine::Machine)\n\nReturn the \"entry\" device, i.e., the device that starts CPU threads and GPU kernels, and takes input values and returns the output value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.set_cache_strategy-Tuple{ComputableDAGs.AbstractDevice, CacheStrategy}","page":"Devices","title":"ComputableDAGs.set_cache_strategy","text":"set_cache_strategy(device::AbstractDevice, cacheStrategy::CacheStrategy)\n\nSets the device's cache strategy. After this call, cache_strategy should return cacheStrategy on the given device.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.strategies-Union{Tuple{Type{T}}, Tuple{T}} where T<:ComputableDAGs.AbstractDevice","page":"Devices","title":"ComputableDAGs.strategies","text":"strategies(t::Type{T}) where {T <: AbstractDevice}\n\nReturn a vector of available CacheStrategys for the given AbstractDevice. The caching strategies are used in code generation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#NUMA","page":"Devices","title":"NUMA","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/numa/impl.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.NumaNode","page":"Devices","title":"ComputableDAGs.NumaNode","text":"NumaNode <: AbstractCPU\n\nRepresentation of a specific CPU that code can run on. Implements the AbstractDevice interface.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs._gen_access_expr-Tuple{NumaNode, Dictionary, Symbol}","page":"Devices","title":"ComputableDAGs._gen_access_expr","text":"_gen_access_expr(device::NumaNode, ::Dictionary, symbol::Symbol)\n\nInternal function for dispatch, used in gen_access_expr.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs._gen_access_expr-Tuple{NumaNode, LocalVariables, Symbol}","page":"Devices","title":"ComputableDAGs._gen_access_expr","text":"_gen_access_expr(device::NumaNode, ::LocalVariables, symbol::Symbol)\n\nInternal function for dispatch, used in gen_access_expr.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.gen_access_expr-Tuple{NumaNode, Symbol}","page":"Devices","title":"ComputableDAGs.gen_access_expr","text":"gen_access_expr(device::NumaNode, symbol::Symbol)\n\nGenerate code to access the variable designated by symbol on a NumaNode, using the CacheStrategy set in the device.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.gen_cache_init_code-Tuple{NumaNode}","page":"Devices","title":"ComputableDAGs.gen_cache_init_code","text":"gen_cache_init_code(device::NumaNode)\n\nGenerate code for initializing the LocalVariables strategy on a NumaNode.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.get_devices-Union{Tuple{Type{T}}, Tuple{T}} where T<:NumaNode","page":"Devices","title":"ComputableDAGs.get_devices","text":"get_devices(deviceType::Type{T}; verbose::Bool) where {T <: NumaNode}\n\nReturn a Vector of NumaNodes available on the current machine. If verbose is true, print some additional information.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#GPUs","page":"Devices","title":"GPUs","text":"","category":"section"},{"location":"lib/internals/devices/","page":"Devices","title":"Devices","text":"Modules = [ComputableDAGs]\nPages = [\"devices/ext.jl\"]\nOrder = [:type]","category":"page"},{"location":"lib/internals/devices/#ComputableDAGs.CUDAGPU","page":"Devices","title":"ComputableDAGs.CUDAGPU","text":"CUDAGPU <: AbstractGPU\n\nRepresentation of a specific CUDA GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires CUDA to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.ROCmGPU","page":"Devices","title":"ComputableDAGs.ROCmGPU","text":"ROCmGPU <: AbstractGPU\n\nRepresentation of a specific AMD GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires AMDGPU to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.oneAPIGPU","page":"Devices","title":"ComputableDAGs.oneAPIGPU","text":"oneAPIGPU <: AbstractGPU\n\nRepresentation of a specific Intel GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires oneAPI to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/scheduler/#Scheduler","page":"Scheduler","title":"Scheduler","text":"","category":"section"},{"location":"lib/internals/scheduler/#Interface","page":"Scheduler","title":"Interface","text":"","category":"section"},{"location":"lib/internals/scheduler/","page":"Scheduler","title":"Scheduler","text":"Modules = [ComputableDAGs]\nPages = [\"scheduler/interface.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/internals/scheduler/#ComputableDAGs.AbstractScheduler","page":"Scheduler","title":"ComputableDAGs.AbstractScheduler","text":"AbstractScheduler\n\nAbstract base type for scheduler implementations. The scheduler is used to assign each node to a device and create a topological ordering of tasks.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/scheduler/#ComputableDAGs.schedule_dag","page":"Scheduler","title":"ComputableDAGs.schedule_dag","text":"schedule_dag(::Scheduler, ::DAG, ::Machine)\n\nInterface functions that must be implemented for implementations of Scheduler.\n\nThe function assigns each ComputeTaskNode of the DAG to one of the devices in the given Machine and returns a Vector{Node} representing a topological ordering.\n\nDataTaskNodes are not scheduled to devices since they do not compute. Instead, a data node transfers data from the AbstractDevice of their child to all AbstractDevices of its parents.\n\nReturn a Vector{FunctionCall}. See FunctionCall\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/scheduler/#Types","page":"Scheduler","title":"Types","text":"","category":"section"},{"location":"lib/internals/scheduler/","page":"Scheduler","title":"Scheduler","text":"Modules = [ComputableDAGs]\nPages = [\"scheduler/type.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/internals/scheduler/#ComputableDAGs.FunctionCall","page":"Scheduler","title":"ComputableDAGs.FunctionCall","text":"FunctionCall{N}\n\nType representing a function call with N parameters. Contains the function to call, argument symbols, the return symbol and the device to execute on.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/scheduler/#Greedy","page":"Scheduler","title":"Greedy","text":"","category":"section"},{"location":"lib/internals/scheduler/","page":"Scheduler","title":"Scheduler","text":"Modules = [ComputableDAGs]\nPages = [\"scheduler/greedy.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"lib/internals/scheduler/#ComputableDAGs.GreedyScheduler","page":"Scheduler","title":"ComputableDAGs.GreedyScheduler","text":"GreedyScheduler\n\nA greedy implementation of a scheduler, creating a topological ordering of nodes and naively balancing them onto the different devices.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"lib/internals/models/#Interface","page":"Models","title":"Interface","text":"","category":"section"},{"location":"lib/internals/models/","page":"Models","title":"Models","text":"The interface that has to be implemented for a model to be usable is defined in src/models/interface.jl.","category":"page"},{"location":"lib/internals/models/","page":"Models","title":"Models","text":"Modules = [ComputableDAGs]\nPages = [\"models/interface.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"lib/internals/models/#ComputableDAGs.AbstractModel","page":"Models","title":"ComputableDAGs.AbstractModel","text":"AbstractModel\n\nBase type for all models. From this, AbstractProblemInstances can be constructed.\n\nSee also: problem_instance\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/models/#ComputableDAGs.AbstractProblemInstance","page":"Models","title":"ComputableDAGs.AbstractProblemInstance","text":"AbstractProblemInstance\n\nBase type for problem instances. An object of this type of a corresponding AbstractModel should uniquely identify a problem instance of that model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/models/#ComputableDAGs.graph","page":"Models","title":"ComputableDAGs.graph","text":"graph(::AbstractProblemInstance)\n\nGenerate the DAG for the given AbstractProblemInstance. Every entry node (see get_entry_nodes) to the graph must have a name set. Implement input_expr to return a valid expression for each of those names.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/models/#ComputableDAGs.input_expr","page":"Models","title":"ComputableDAGs.input_expr","text":"input_expr(instance::AbstractProblemInstance, name::String, input_symbol::Symbol)\n\nFor the given AbstractProblemInstance, the entry node name, and the symbol of the problem input (where a variable of type input_type(...) will exist), return an Expr that gets that specific input value from the input symbol.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/models/#ComputableDAGs.input_type","page":"Models","title":"ComputableDAGs.input_type","text":"input_type(problem::AbstractProblemInstance)\n\nReturn the input type for a specific AbstractProblemInstance. This can be a specific type or a supertype for which all child types are expected to work.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/models/#ComputableDAGs.problem_instance","page":"Models","title":"ComputableDAGs.problem_instance","text":"problem_instance(::AbstractModel, ::Vararg)\n\nInterface function that must be implemented for any implementation of AbstractModel. This function should return a specific AbstractProblemInstance given some parameters.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"lib/internals/optimization/#Interface","page":"Optimization","title":"Interface","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"The interface that has to be implemented for an optimization algorithm.","category":"page"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [ComputableDAGs]\nPages = [\"optimization/interface.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.AbstractOptimizer","page":"Optimization","title":"ComputableDAGs.AbstractOptimizer","text":"AbstractOptimizer\n\nAbstract base type for optimizer implementations.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#ComputableDAGs.fixpoint_reached-Tuple{AbstractOptimizer, DAG}","page":"Optimization","title":"ComputableDAGs.fixpoint_reached","text":"fixpoint_reached(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that can be implemented by optimization algorithms that can reach a fixpoint, returning as a Bool whether it has been reached. The default implementation returns false.\n\nSee also: optimize_to_fixpoint!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize!-Tuple{AbstractOptimizer, DAG, Int64}","page":"Optimization","title":"ComputableDAGs.optimize!","text":"optimize!(optimizer::AbstractOptimizer, graph::DAG, n::Int)\n\nFunction calling the given optimizer n times, muting the graph. Returns true if the requested number of operations has been applied, false if not, usually when a fixpoint of the algorithm has been reached.\n\nIf a more efficient method exists, this can be overloaded for a specific optimizer.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize_step!","page":"Optimization","title":"ComputableDAGs.optimize_step!","text":"optimize_step!(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that must be implemented by implementations of AbstractOptimizer. Returns true if an operations has been applied, false if not, usually when a fixpoint of the algorithm has been reached.\n\nIt should do one smallest logical step on the given DAG, muting the graph and, if necessary, the optimizer's state.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize_to_fixpoint!","page":"Optimization","title":"ComputableDAGs.optimize_to_fixpoint!","text":"optimize_to_fixpoint!(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that can be implemented by optimization algorithms that can reach a fixpoint. The algorithm will be run until that fixpoint is reached, at which point fixpoint_reached should return true.\n\nA usual implementation might look like this:\n\n    function optimize_to_fixpoint!(optimizer::MyOptimizer, graph::DAG)\n        while !fixpoint_reached(optimizer, graph)\n            optimize_step!(optimizer, graph)\n        end\n        return nothing\n    end\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#Random-Walk-Optimizer","page":"Optimization","title":"Random Walk Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a random walk algorithm.","category":"page"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [ComputableDAGs]\nPages = [\"optimization/random_walk.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.RandomWalkOptimizer","page":"Optimization","title":"ComputableDAGs.RandomWalkOptimizer","text":"RandomWalkOptimizer\n\nAn optimizer that randomly pushes or pops operations. It doesn't optimize in any direction and is useful mainly for testing purposes.\n\nThis algorithm never reaches a fixpoint, so it does not implement optimize_to_fixpoint!.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Reduction-Optimizer","page":"Optimization","title":"Reduction Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a an optimizer that reduces as far as possible.","category":"page"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [ComputableDAGs]\nPages = [\"optimization/reduce.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.ReductionOptimizer","page":"Optimization","title":"ComputableDAGs.ReductionOptimizer","text":"ReductionOptimizer\n\nAn optimizer that simply applies an available NodeReduction on each step. It implements optimize_to_fixpoint!. The fixpoint is reached when there are no more possible NodeReductions in the graph.\n\nSee also: SplitOptimizer\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Split-Optimizer","page":"Optimization","title":"Split Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of an optimizer that splits as far as possible.","category":"page"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [ComputableDAGs]\nPages = [\"optimization/split.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.SplitOptimizer","page":"Optimization","title":"ComputableDAGs.SplitOptimizer","text":"SplitOptimizer\n\nAn optimizer that simply applies an available NodeSplit on each step. It implements optimize_to_fixpoint!. The fixpoint is reached when there are no more possible NodeSplits in the graph.\n\nSee also: ReductionOptimizer\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Greedy-Optimizer","page":"Optimization","title":"Greedy Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a greedy optimization algorithm.","category":"page"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [ComputableDAGs]\nPages = [\"optimization/greedy.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.GreedyOptimizer","page":"Optimization","title":"ComputableDAGs.GreedyOptimizer","text":"GreedyOptimizer\n\nAn implementation of the greedy optimization algorithm, simply choosing the best next option evaluated with the given estimator.\n\nThe fixpoint is reached when any leftover operation would increase the graph's total cost according to the given estimator.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#Graph","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"lib/internals/graph/#Type","page":"Graph","title":"Type","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/type.jl\"]\nOrder   = [:type]","category":"page"},{"location":"lib/internals/graph/#ComputableDAGs.DAG","page":"Graph","title":"ComputableDAGs.DAG","text":"DAG\n\nThe representation of the graph as a set of Nodes.\n\nOperations can be applied on it using push_operation! and reverted using pop_operation! like a stack. To get the set of possible operations, use get_operations. The members of the object should not be manually accessed, instead always use the provided interface functions.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#ComputableDAGs.DAG-Tuple{}","page":"Graph","title":"ComputableDAGs.DAG","text":"DAG()\n\nConstruct and return an empty DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.PossibleOperations","page":"Graph","title":"ComputableDAGs.PossibleOperations","text":"PossibleOperations\n\nA struct storing all possible operations on a DAG. To get the PossibleOperations on a DAG, use get_operations.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#ComputableDAGs.PossibleOperations-Tuple{}","page":"Graph","title":"ComputableDAGs.PossibleOperations","text":"PossibleOperations()\n\nConstruct and return an empty PossibleOperations object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Interface","page":"Graph","title":"Interface","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/interface.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#ComputableDAGs.can_pop-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.can_pop","text":"can_pop(graph::DAG)\n\nReturn true if pop_operation! is possible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.pop_operation!-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.pop_operation!","text":"pop_operation!(graph::DAG)\n\nRevert the latest applied operation on the graph.\n\nSee also: DAG, push_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.push_operation!-Tuple{DAG, Operation}","page":"Graph","title":"ComputableDAGs.push_operation!","text":"push_operation!(graph::DAG, operation::Operation)\n\nApply a new operation to the graph.\n\nSee also: DAG, pop_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.reset_graph!-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.reset_graph!","text":"reset_graph!(graph::DAG)\n\nReset the graph to its initial state with no operations applied.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Compare","page":"Graph","title":"Compare","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/compare.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#Base.in-Tuple{Edge, DAG}","page":"Graph","title":"Base.in","text":"in(edge::Edge, graph::DAG)\n\nCheck whether the edge is part of the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Base.in-Tuple{Node, DAG}","page":"Graph","title":"Base.in","text":"in(node::Node, graph::DAG)\n\nCheck whether the node is part of the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Mute","page":"Graph","title":"Mute","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/mute.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#ComputableDAGs._insert_edge!","page":"Graph","title":"ComputableDAGs._insert_edge!","text":"_insert_edge!(graph::DAG, node1::Node, node2::Node, index::Int=0; track = true, invalidate_cache = true)\n\nInsert the edge between node1 (child) and node2 (parent) into the graph. An optional integer index can be given. The arguments of the function call that this node compiles to will then be ordered by these indices.\n\nwarning: Warning\nFor creating new graphs, use the public version insert_edge! instead which uses the defaults false for the keywords.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _remove_node!, _remove_edge!\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/graph/#ComputableDAGs._insert_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs._insert_node!","text":"_insert_node!(graph::DAG, node::Node; track = true, invalidate_cache = true)\n\nInsert the node into the graph.\n\nwarning: Warning\nFor creating new graphs, use the public version insert_node! instead which uses the defaults false for the keywords.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\n\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _remove_node!, _insert_edge!, _remove_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs._remove_edge!-Tuple{DAG, Node, Node}","page":"Graph","title":"ComputableDAGs._remove_edge!","text":"_remove_edge!(graph::DAG, node1::Node, node2::Node; track = true, invalidate_cache = true)\n\nRemove the edge between node1 (child) and node2 (parent) into the graph. Returns the integer index of the removed edge.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _remove_node!, _insert_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs._remove_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs._remove_node!","text":"_remove_node!(graph::DAG, node::Node; track = true, invalidate_cache = true)\n\nRemove the node from the graph.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\n\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _insert_edge!, _remove_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_snapshot_diff-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_snapshot_diff","text":"get_snapshot_diff(graph::DAG)\n\nReturn the graph's Diff since last time this function was called.\n\nSee also: revert_diff!, AppliedOperation and revert_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.insert_edge!","page":"Graph","title":"ComputableDAGs.insert_edge!","text":"insert_edge!(graph::DAG, node1::Node, node2::Node)\n\nInsert the edge between node1 (child) and node2 (parent) into the graph.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/graph/#ComputableDAGs.insert_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs.insert_node!","text":"insert_node!(graph::DAG, node::Node)\ninsert_node!(graph::DAG, task::AbstractTask, name::String=\"\")\n\nInsert the node into the graph or alternatively construct a node from the given task and insert it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.invalidate_caches!-Tuple{DAG, NodeReduction}","page":"Graph","title":"ComputableDAGs.invalidate_caches!","text":"invalidate_caches!(graph::DAG, operation::NodeReduction)\n\nInvalidate the operation caches for a given NodeReduction.\n\nThis deletes the operation from the graph's possible operations and from the involved nodes' own operation caches.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.invalidate_caches!-Tuple{DAG, NodeSplit}","page":"Graph","title":"ComputableDAGs.invalidate_caches!","text":"invalidate_caches!(graph::DAG, operation::NodeSplit)\n\nInvalidate the operation caches for a given NodeSplit.\n\nThis deletes the operation from the graph's possible operations and from the involved nodes' own operation caches.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.invalidate_operation_caches!-Tuple{DAG, ComputeTaskNode}","page":"Graph","title":"ComputableDAGs.invalidate_operation_caches!","text":"invalidate_operation_caches!(graph::DAG, node::ComputeTaskNode)\n\nInvalidate the operation caches of the given node through calls to the respective invalidate_caches! functions.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.invalidate_operation_caches!-Tuple{DAG, DataTaskNode}","page":"Graph","title":"ComputableDAGs.invalidate_operation_caches!","text":"invalidate_operation_caches!(graph::DAG, node::DataTaskNode)\n\nInvalidate the operation caches of the given node through calls to the respective invalidate_caches! functions.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Print","page":"Graph","title":"Print","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/print.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#Base.show-Tuple{IO, DAG}","page":"Graph","title":"Base.show","text":"show(io::IO, graph::DAG)\n\nPrint the given graph to io. If there are too many nodes it will print only a summary of them.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.show_nodes-Tuple{IO, DAG}","page":"Graph","title":"ComputableDAGs.show_nodes","text":"show_nodes(io::IO, graph::DAG)\n\nPrint a graph's nodes. Should only be used for small graphs as it prints every node in a list.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Properties","page":"Graph","title":"Properties","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/properties.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#ComputableDAGs.get_entry_nodes-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_entry_nodes","text":"get_entry_nodes(graph::DAG)\n\nReturn a vector of the graph's entry nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_exit_node-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_exit_node","text":"get_exit_node(graph::DAG)\n\nReturn the graph's exit node. This assumes the graph only has a single exit node. If the graph has multiple exit nodes, the one encountered first will be returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_properties-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_properties","text":"get_properties(graph::DAG)\n\nReturn the graph's GraphProperties.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.operation_stack_length-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.operation_stack_length","text":"operation_stack_length(graph::DAG)\n\nReturn the number of operations applied to the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Validate","page":"Graph","title":"Validate","text":"","category":"section"},{"location":"lib/internals/graph/","page":"Graph","title":"Graph","text":"Modules = [ComputableDAGs]\nPages = [\"graph/validate.jl\"]\nOrder   = [:function]","category":"page"},{"location":"lib/internals/graph/#ComputableDAGs.is_connected-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.is_connected","text":"is_connected(graph::DAG)\n\nReturn whether the given graph is connected.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.is_scheduled-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.is_scheduled","text":"is_scheduled(graph::DAG)\n\nValidate that the entire graph has been scheduled, i.e., every ComputeTaskNode has its .device set.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.is_valid-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.is_valid","text":"is_valid(graph::DAG)\n\nValidate the entire graph using asserts. Intended for testing with @assert is_valid(graph).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/estimator/#Estimation","page":"Estimation","title":"Estimation","text":"","category":"section"},{"location":"lib/internals/estimator/#Interface","page":"Estimation","title":"Interface","text":"","category":"section"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"The interface that has to be implemented for an estimator.","category":"page"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"Modules = [ComputableDAGs]\nPages = [\"estimator/interface.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"lib/internals/estimator/#ComputableDAGs.AbstractEstimator","page":"Estimation","title":"ComputableDAGs.AbstractEstimator","text":"AbstractEstimator\n\nAbstract base type for an estimator. An estimator estimates the cost of a graph or the difference an operation applied to a graph will make to its cost.\n\nInterface functions are\n\ngraph_cost\noperation_effect\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/estimator/#ComputableDAGs.cost_type","page":"Estimation","title":"ComputableDAGs.cost_type","text":"cost_type(estimator::AbstractEstimator)\n\nInterface function returning a specific estimator's cost type, i.e., the type returned by its implementation of graph_cost and operation_effect.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/estimator/#ComputableDAGs.graph_cost","page":"Estimation","title":"ComputableDAGs.graph_cost","text":"graph_cost(estimator::AbstractEstimator, graph::DAG)\n\nGet the total estimated cost of the graph. The cost's data type can be chosen by the implementation, but must have a usable lessthan comparison operator (<), basic math operators (+, -) and an implementation of zero() and typemax().\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/estimator/#ComputableDAGs.operation_effect-Tuple{ComputableDAGs.AbstractEstimator, DAG, Operation}","page":"Estimation","title":"ComputableDAGs.operation_effect","text":"operation_effect(estimator::AbstractEstimator, graph::DAG, operation::Operation)\n\nGet the estimated effect on the cost of the graph, such that graph_cost(estimator, graph) + operation_effect(estimator, graph, operation) ~= graph_cost(estimator, graph_with_operation_applied). There is no hard requirement for this, but the better the estimate, the better an optimization algorithm will be.\n\nnote: Note\nThere is a default implementation of this function, applying the operation, calling graph_cost, then popping the operation again.It can be much faster to overload this function for a specific estimator and directly compute the effects from the operation if possible.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/estimator/#Global-Metric-Estimator","page":"Estimation","title":"Global Metric Estimator","text":"","category":"section"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"Implementation of a global metric estimator. It uses the graph properties compute effort, data transfer, and compute intensity.","category":"page"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"Modules = [ComputableDAGs]\nPages = [\"estimator/global_metric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"lib/internals/estimator/#ComputableDAGs.CDCost","page":"Estimation","title":"ComputableDAGs.CDCost","text":"CDCost\n\nRepresentation of a DAG's cost as estimated by the GlobalMetricEstimator.\n\nFields:\n\n.data: The total data transfer.\n.computeEffort: The total compute effort.\n.computeIntensity: The compute intensity, will always equal .computeEffort / .data.\n\nnote: Note\nNote that the computeIntensity doesn't necessarily make sense in the context of only operation costs. It will still work as intended when adding/subtracting to/from a graph_cost estimate.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/estimator/#ComputableDAGs.GlobalMetricEstimator","page":"Estimation","title":"ComputableDAGs.GlobalMetricEstimator","text":"GlobalMetricEstimator <: AbstractEstimator\n\nA simple estimator that adds up each node's set compute_effort and data.\n\n\n\n\n\n","category":"type"},{"location":"#ComputableDAGs.jl","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"A domain-specific DAG-optimizer","category":"page"},{"location":"#General","page":"ComputableDAGs.jl","title":"General","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"This packages provides a way to represent large computations in a graph representation. Once such a graph is created, it can","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"be analyzed to extract properties such as total compute effort or data transfer necessary,\nbe optimized using optimization algorithms,\nbe scheduled on heterogeneous machines, making use of all available hardware\nbe compiled and executed within the same session of julia.","category":"page"},{"location":"#Requirements-for-use","page":"ComputableDAGs.jl","title":"Requirements for use","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"There are some hard requirements for this to be possible to a specific computation problem:","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The computation must be static, i.e., the structure of the graph may not dynamically change during the computation.\nAll data dependencies within the graph must be known in advance.\nThe overall computation must be separable into smaller parts with less than total interdependency.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Some more soft requirements exist for the project to be useful:","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"For optimizations to be effective, the functions should have a predictable compute effort that can be known in advance.\nThe individual tasks should not be too small (ideally at least a few dozen FLOPs) because the compiler is smarter at optimizing very small functions than we can be.\nThe individual tasks should not be too large so the graph has a large enough number of nodes to allow for a larger optimization space.\nTasks should not have side-effects because the order and number of times a function is executed can not be relied upon.","category":"page"},{"location":"#Overview-of-the-Project-Structure","page":"ComputableDAGs.jl","title":"Overview of the Project Structure","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"(Image: Parts of the Project)","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The project consists of several parts that are designed to be mostly orthogonal interfaces, extendable with new implementations without having to change other parts of the code. For example implementations, refer to the manual, the tests, or other projects in the ComputableDAGs project.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The Graph is the central part. It consists of Nodes and Edges. Nodes represent a Task, which is either a computation or a data transfer. Edges purely represent the dependencies between the nodes.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"A graph has to be generated first, which is done by defining a Model and providing some form of Generator for a specific problem instance of that model. This part is entirely up to the user. A generator might parse a file and generate a graph from that, or it may generate a basic graph by itself.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Estimators can be used to collect properties of the graph, for example the total compute effort defined by tasks.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"From any state of the graph, possible Operations can be generated. These represent topological changes to the graph which do not change the total computation. Operations can be applied and popped similar to a stack.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The Optimizer interface then allows to use an estimator to push and pop operations to reduce the execution time.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Finally, the Scheduler can use Device information to generate the code.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"For detailed information on all the interfaces und functionality provided, please refer to the public documentation or the respective internals, as linked above.","category":"page"},{"location":"#Library-Outline","page":"ComputableDAGs.jl","title":"Library Outline","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/internals.md\"\n]","category":"page"},{"location":"#main-index","page":"ComputableDAGs.jl","title":"Index","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Pages = [\"lib/public.md\"]","category":"page"}]
}
