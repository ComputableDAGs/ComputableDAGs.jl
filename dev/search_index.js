var documenterSearchIndex = {"docs":
[{"location":"contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Feel free to open issues or pull requests to the official repository. Ideas, tips, bug reports, or contributions are all welcome.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for ComputableDAGs.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for documentation of everything else.","category":"page"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 2","category":"page"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Module","page":"Public","title":"Module","text":"","category":"section"},{"location":"lib/public/#ComputableDAGs.ComputableDAGs","page":"Public","title":"ComputableDAGs.ComputableDAGs","text":"ComputableDAGs\n\nA module containing tools to represent computations as DAGs.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Macros","page":"Public","title":"Macros","text":"","category":"section"},{"location":"lib/public/#ComputableDAGs.@add_call-Tuple{Any, Any, Vararg{Any}}","page":"Public","title":"ComputableDAGs.@add_call","text":"@add_call task data varargs\n\nnote: Note\nOnly valid within a @assemble_dag block.\n\nTakes an AbstractComputeTask and arguments in the form of ComputeTaskNodes, creating a node in the dag currently being assembled (see @assemble_dag). The resulting node is returned to be used in subsequent @add_calls.\n\nArguments\n\ntask: The actual ComputeTask object to use.\ndata: The data size of the result.\nvarargs...: Any number of data nodes to use as input. They will be given to the task's function in the same order. Each argument can also be an iterable (vector, tuple, etc.) of nodes, which are automatically unpacked and added individually.\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#ComputableDAGs.@add_entry-Tuple{Any, Any}","page":"Public","title":"ComputableDAGs.@add_entry","text":"@add_entry name data\n\nnote: Note\nOnly valid within a @assemble_dag block.\n\nAdd an entry node to the DAG currently being assembled, with the given name and expected resulting data size. An input_expr must be defined for the given name.\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#ComputableDAGs.@assemble_dag-Tuple{Any}","page":"Public","title":"ComputableDAGs.@assemble_dag","text":"@assemble_dag begin ... end\n\nTakes a code block within which the @add_call and @add_entry macros can be used. It returns the fully assembled DAG.\n\nThis macro can not be used recursively.\n\nExample:\n\ndag = @assemble_dag begin\n    entry_node = @add_entry \"input\" 64 # name and data size\n    compute1 = @add_call Compute1() 32 entry_node # task, output data size, and inputs\n    compute2 = @add_call Compute2() 16 compute1 entry_node # task, output data size, and inputs of the second compute node\n    # since no more nodes are added, compute2 is automatically the final result of the dag\nend\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#ComputableDAGs.@compute_task-Tuple{Any, Any, Any}","page":"Public","title":"ComputableDAGs.@compute_task","text":"@compute_task task effort [function]\n\nDefines a compute task to be later added in compute nodes to a DAG, for example using @add_call. Necessary arguments are the task name and its expected compute effort. Optionally, a function can be provided, making up the task's compute function. For example, to add a task type that simply adds two child nodes together:\n\n@compute_task Add 1 (+)\n\nIn some cases, the function to call might be more complex or need more specific information about the task type, like its type parametrization. For this reason, it is also possible to define the compute function for a compute task manually instead:\n\n@compute_task ComplexTask{T1, T2} 50\nComputableDAGs.compute(::ComplexTask{Int, Float32}, v1, v2) = ...\nComputableDAGs.compute(::ComplexTask{String, Float32}, v1, v2) = ...\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/internals/utility/#Helper-Functions","page":"Utility","title":"Helper Functions","text":"","category":"section"},{"location":"lib/internals/utility/#ComputableDAGs._lt_node_tuples-Tuple{Tuple{Base.UUID, Int64}, Tuple{Base.UUID, Int64}}","page":"Utility","title":"ComputableDAGs._lt_node_tuples","text":"_lt_node_tuples(n1::Tuple{Node, Int}, n2::Tuple{Node, Int})\n\nLess-Than comparison between nodes with indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.bytes_to_human_readable-Tuple{Any}","page":"Utility","title":"ComputableDAGs.bytes_to_human_readable","text":"bytes_to_human_readable(bytes)\n\nReturn a human readable string representation of the given number.\n\njulia> using ComputableDAGs\n\njulia> ComputableDAGs.bytes_to_human_readable(4096)\n\"4.0 KiB\"\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.infer_types!-Tuple{ComputableDAGs.Tape, Module}","page":"Utility","title":"ComputableDAGs.infer_types!","text":"infer_types!(tape::Tape, context_module::Module)\n\nInfer the result type of each function call in the given tape. Returns a dictionary with the result type for each symbol and sets each function call's return_types. This function assumes that each FunctionCall has only one statically inferrable return type and will throw an exception otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.lower-Tuple{Vector{Tuple{Node, ComputableDAGs.AbstractDevice}}, Machine}","page":"Utility","title":"ComputableDAGs.lower","text":"lower(schedule::Vector{Node}, machine::Machine)\n\nAfter schedule_dag has made a schedule of nodes, this function lowers the vector of Nodes and AbstractDevices into a vector of FunctionCalls.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.noop-Tuple{}","page":"Utility","title":"ComputableDAGs.noop","text":"noop()\n\nFunction with no arguments, returns nothing, does nothing. Useful for noop FunctionCalls.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.sort_node!-Tuple{Node}","page":"Utility","title":"ComputableDAGs.sort_node!","text":"sort_node!(node::Node)\n\nSort the nodes' parents and children vectors. The vectors are mostly very short so sorting does not take a lot of time. Sorted nodes are required to make the finding of NodeReductions a lot faster using the NodeTrie data structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.unroll_symbol_vector-Tuple{VEC} where VEC<:Union{Tuple, AbstractVector}","page":"Utility","title":"ComputableDAGs.unroll_symbol_vector","text":"unroll_symbol_vector(vec::Vector{Symbol})\n\nReturn the given vector as single String without quotation marks or brackets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Trie-Helper","page":"Utility","title":"Trie Helper","text":"","category":"section"},{"location":"lib/internals/utility/","page":"Utility","title":"Utility","text":"This is a simple implementation of a Trie Data Structure to greatly improve the performance of the Node Reduction search.","category":"page"},{"location":"lib/internals/utility/#ComputableDAGs.NodeIdTrie","page":"Utility","title":"ComputableDAGs.NodeIdTrie","text":"NodeIdTrie\n\nHelper struct for NodeTrie. After the Trie's first level, every Trie level contains the vector of nodes that had children up to that level, and the TrieNode's children by UUID of the node's children.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/utility/#ComputableDAGs.NodeIdTrie-Union{Tuple{}, Tuple{NodeType}} where NodeType<:Node","page":"Utility","title":"ComputableDAGs.NodeIdTrie","text":"NodeIdTrie()\n\nConstructor for an empty NodeIdTrie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.NodeTrie","page":"Utility","title":"ComputableDAGs.NodeTrie","text":"NodeTrie\n\nTrie data structure for node reduction, inserts nodes by children. Assumes that given nodes have ordered vectors of children (see sort_node!). First insertion level is the node's own task type + name and thus does not have a value (every node has a task type).\n\nSee also: insert! and collect\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/utility/#ComputableDAGs.NodeTrie-Tuple{}","page":"Utility","title":"ComputableDAGs.NodeTrie","text":"NodeTrie()\n\nConstructor for an empty NodeTrie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Base.collect-Tuple{ComputableDAGs.NodeTrie}","page":"Utility","title":"Base.collect","text":"collect(trie::NodeTrie)\n\nReturn all sets of at least 2 Nodes that have accumulated in leaves of the trie.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#Base.insert!-Union{Tuple{NodeType}, Tuple{ComputableDAGs.NodeTrie, NodeType}} where NodeType<:Node","page":"Utility","title":"Base.insert!","text":"insert!(trie::NodeTrie, node::Node)\n\nInsert the given node into the trie. It's sorted by its type in the first layer, then by its children in the following layers.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.collect_helper-Tuple{ComputableDAGs.NodeIdTrie, Set{Vector{Node}}}","page":"Utility","title":"ComputableDAGs.collect_helper","text":"collect_helper(trie::NodeIdTrie, acc::Set{Vector{Node}})\n\nCollects the Vectors of this NodeIdTrie node and all its children and puts them in the acc argument.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/utility/#ComputableDAGs.insert_helper!-Union{Tuple{NodeType}, Tuple{ComputableDAGs.NodeIdTrie{NodeType}, NodeType, Int64}} where NodeType<:Node","page":"Utility","title":"ComputableDAGs.insert_helper!","text":"insert_helper!(trie::NodeIdTrie, node::Node, depth::Int)\n\nInsert the given node into the trie. The depth is used to iterate through the trie layers, while the function calls itself recursively until it ran through all children of the node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#Code-Generation","page":"Code Generation","title":"Code Generation","text":"","category":"section"},{"location":"lib/internals/code_gen/#Types","page":"Code Generation","title":"Types","text":"","category":"section"},{"location":"lib/internals/code_gen/#ComputableDAGs.FunctionCall","page":"Code Generation","title":"ComputableDAGs.FunctionCall","text":"FunctionCall{VAL_T<:Tuple,FUNC_T<:Union{Function,Expr}}\n\nRepresentation of a function call. Contains the function to call (or an expression of a value to assign), value arguments of type VAL_T, argument symbols, the return symbol(s) and type(s) and the device to execute on.\n\nTo support vectorization, i.e., calling the same function on multiple inputs (SIMD), the value arguments, arguments, and return symbols are each vectors of the actual inputs. In the non-vectorized case, these Vectors simply always have length 1. For this common case, a special constructor exists which automatically wraps each of these arguments in a Vector.\n\nType Arguments\n\nVAL_T<:Tuple: A tuple of all the value arguments that are passed to the function when it's called.\nFUNC_T<:Union{Function, Expr}: The type of the function. Function is the default, but in some cases, an Expr   of a value can be necessary to assign to the return symbol. In this case, no arguments are allowed.\n\nFields\n\nfunc::FUNC_T: The function to be called, or an expression containing a value to assign to the return_symbol.\nvalue_arguments::Vector{VAL_T}: The value arguments for the function call. These are passed first to the   function, in the order given here. The Vector contains the tuple of value arguments for each vectorization   member.\narguments::Vector{Vector{Symbol}}: The first vector represents the vectorization, the second layer represents the   symbols that will be passed as arguments to the function call.\nreturn_symbols::Vector{Vector{Symbol}}: As with the arguments, the first vector level represents the vectorization,   the second represents the symbols that the results of the function call are assigned to. For most function calls,   there is only one return symbol. When using closures when generating a function body for a Tape, the   option to have multiple return symbols is necessary.\nreturn_types::Vector{<:Type}: The types of the function call with the arguments provided. This field only contains   one level of Vector, because it is required that a FunctionCall is type stable, and therefore, the types of the   return symbols have to be equal for all members of a vectorization. The return type is initially set to Nothing   and later inferred and assigned by infer_types!.\ndevice::AbstractDevice: The device that this function call is scheduled on.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/code_gen/#ComputableDAGs.Tape","page":"Code Generation","title":"ComputableDAGs.Tape","text":"Tape{INPUT}\n\nLowered representation of a computation, generated from a DAG through gen_tape.\n\nINPUT the input type of the problem instance, see also the interface function input_type\n\nFields\n\ninput_assign_code::Vector{FunctionCall}: The FunctionCalls representing the input assignments,   mapping part of the input of the computation to each DAG entry node. These functions are generated using   the interface function input_expr.\nschedule::Vector{FunctionCall}: The FunctionCalls representing the function body of the computation.   There is one function call for each node in the DAG.\noutput_symbol::Symbol: The symbol of the final calculated value, which is returned.\ninstance::Any: The instance that this tape is generated for.\nmachine::Machine: The Machine that this tape is generated for.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/code_gen/#Function-Generation","page":"Code Generation","title":"Function Generation","text":"","category":"section"},{"location":"lib/internals/code_gen/","page":"Code Generation","title":"Code Generation","text":"Implementations for generation of a callable function. A function generated this way cannot immediately be called. One Julia World Age has to pass before this is possible, which happens when the global Julia scope advances. If the DAG and therefore the generated function becomes too large, use the tape machine instead, since compiling large functions becomes infeasible.","category":"page"},{"location":"lib/internals/code_gen/#ComputableDAGs.get_compute_function-Tuple{DAG, Any, Machine, Module}","page":"Code Generation","title":"ComputableDAGs.get_compute_function","text":"get_compute_function(\n    dag::DAG,\n    instance,\n    machine::Machine,\n    context_module::Module\n)\n\nReturn a function of signature compute_<id>(input::input_type(instance)), which will return the result of the DAG computation on the given input. The final argument context_module should always be @__MODULE__ to be able to use functions defined in the caller's environment.\n\nKeyword Arguments\n\nclosures_size (default=0 (off)): The size of closures to use in the main generated code. This specifies the size of code blocks across which the         compiler cannot optimize. For sufficiently large functions, a larger value means longer compile times but potentially faster execution time.         Note that the actually used closure size might be different than the one passed here, since the function automatically chooses a size that         is close to a n-th root of the total number of loc, based off the given size. concrete_input_type (default=input_type(instance)): A type that will be used as the expected input type of the generated function. If     omitted, the input_type of the problem instance is used. Note that the input_type of the instance will still be used as the annotated     type in the generated function header.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#Tape-Machine","page":"Code Generation","title":"Tape Machine","text":"","category":"section"},{"location":"lib/internals/code_gen/#ComputableDAGs._closure_fc-Tuple{AbstractVector{ComputableDAGs.FunctionCall}, Dict{Symbol, Type}, Machine, Set{Symbol}, Module}","page":"Code Generation","title":"ComputableDAGs._closure_fc","text":"_closure_fc(\n    code_block::AbstractVector{FunctionCall},\n    types::Dict{Symbol,Type},\n    machine::Machine,\n    undefined_argument_symbols::Set{Symbol},\n    context_module::Module,\n)\n\nFrom the given function calls, make and return 2 function calls representing all of them together. 2 function calls are necessary, one for setting up the anonymous function and the second for calling it. The undefinedargumentsymbols is the set of all Symbols that need to be returned if available inside the code_block. They get updated inside this function.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_function_body-Tuple{ComputableDAGs.Tape, Module}","page":"Code Generation","title":"ComputableDAGs.gen_function_body","text":"gen_function_body(tape::Tape, context_module::Module; closures_size)\n\nGenerate the function body from the given Tape.\n\nKeyword Arguments\n\nclosures_size: The size of closures to generate (in lines of code). Closures introduce function barriers     in the function body, preventing some optimizations by the compiler and therefore greatly reducing     compile time. A value of 0 will disable the use of closures entirely. concrete_input_type: A type that will be used as the expected input type of the generated function. If     omitted, the input_type of the problem instance is used.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_input_assignment_code-Tuple{Dict{String, Vector{Symbol}}, Any, Machine}","page":"Code Generation","title":"ComputableDAGs.gen_input_assignment_code","text":"gen_input_assignment_code(\n    input_symbols::Dict{String, Vector{Symbol}},\n    instance::Any,\n    machine::Machine,\n    input_type::Type,\n    context_module::Module\n)\n\nReturn a Vector{Expr} doing the input assignments from the given problem_input onto the input_symbols.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/code_gen/#ComputableDAGs.gen_tape","page":"Code Generation","title":"ComputableDAGs.gen_tape","text":"gen_tape(\n    dag::DAG,\n    instance::Any,\n    machine::Machine,\n    context_module::Module,\n    scheduler::AbstractScheduler = GreedyScheduler()\n)\n\nGenerate the code for a given graph. The return value is a Tape.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#Task","page":"Task","title":"Task","text":"","category":"section"},{"location":"lib/internals/task/#Type","page":"Task","title":"Type","text":"","category":"section"},{"location":"lib/internals/task/#ComputableDAGs.AbstractComputeTask","page":"Task","title":"ComputableDAGs.AbstractComputeTask","text":"AbstractComputeTask <: AbstractTask\n\nThe shared base type for any compute task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.AbstractDataTask","page":"Task","title":"ComputableDAGs.AbstractDataTask","text":"AbstractDataTask <: AbstractTask\n\nThe shared base type for any data task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.AbstractTask","page":"Task","title":"ComputableDAGs.AbstractTask","text":"AbstractTask\n\nThe shared base type for any task.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.DataTask","page":"Task","title":"ComputableDAGs.DataTask","text":"DataTask <: AbstractDataTask\n\nTask representing a specific data transfer.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#ComputableDAGs.VectorizedComputeTask","page":"Task","title":"ComputableDAGs.VectorizedComputeTask","text":"VectorizedComputeTask{TASK_T<:AbstractComputeTask} <: AbstractComputeTask\n\nTask representing a vectorized version of another compute task.\n\nwarn: Warn\nThe feature of node vectorization is not fully implemented and will not work yet.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/task/#Create","page":"Task","title":"Create","text":"","category":"section"},{"location":"lib/internals/task/#Base.copy-Tuple{AbstractComputeTask}","page":"Task","title":"Base.copy","text":"copy(t::AbstractComputeTask)\n\nReturn a copy of the given compute task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.copy-Tuple{AbstractDataTask}","page":"Task","title":"Base.copy","text":"copy(t::AbstractDataTask)\n\nFallback implementation of the copy of an abstract data task, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Compare","page":"Task","title":"Compare","text":"","category":"section"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractComputeTask, AbstractComputeTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractComputeTask, t2::AbstractComputeTask)\n\nEquality comparison between two compute tasks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractDataTask, AbstractDataTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractDataTask, t2::AbstractDataTask)\n\nEquality comparison between two data tasks.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Base.:==-Tuple{AbstractTask, AbstractTask}","page":"Task","title":"Base.:==","text":"==(t1::AbstractTask, t2::AbstractTask)\n\nFallback implementation of equality comparison between two abstract tasks. Always returns false. For equal specific types of t1 and t2, a more specific comparison is called instead, doing an actual comparison.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Compute","page":"Task","title":"Compute","text":"","category":"section"},{"location":"lib/internals/task/#ComputableDAGs.get_function_call-Union{Tuple{N}, Tuple{AbstractComputeTask, ComputableDAGs.AbstractDevice, Tuple{Vararg{Symbol, N}}, Symbol}} where N","page":"Task","title":"ComputableDAGs.get_function_call","text":"get_function_call(n::Node)\nget_function_call(t::AbstractTask, device::AbstractDevice, in_symbols::NTuple{}, out_symbol::Symbol)\n\nFor a node or a task together with necessary information, a FunctionCalls for the computation of the node or task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#Properties","page":"Task","title":"Properties","text":"","category":"section"},{"location":"lib/internals/task/#Base.copy-Tuple{DataTask}","page":"Task","title":"Base.copy","text":"copy(t::DataTask)\n\nCopy the data task and return it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.compute","page":"Task","title":"ComputableDAGs.compute","text":"compute(t::AbstractTask; data...)\n\nFallback implementation of the compute function of a compute task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.compute_effort","page":"Task","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::AbstractTask)\n\nFallback implementation of the compute effort of a task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.compute_effort-Tuple{AbstractDataTask}","page":"Task","title":"ComputableDAGs.compute_effort","text":"compute_effort(t::AbstractDataTask)\n\nReturn the compute effort of a data task, always zero, regardless of the specific task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.data","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractTask)\n\nFallback implementation of the data of a task, throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/task/#ComputableDAGs.data-Tuple{AbstractComputeTask}","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractComputeTask)\n\nReturn the data of a compute task, always zero, regardless of the specific task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/task/#ComputableDAGs.data-Tuple{AbstractDataTask}","page":"Task","title":"ComputableDAGs.data","text":"data(t::AbstractDataTask)\n\nReturn the data of a data task. Given by the task's .data field.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/diff/#Diff","page":"Diff","title":"Diff","text":"","category":"section"},{"location":"lib/internals/diff/#Type","page":"Diff","title":"Type","text":"","category":"section"},{"location":"lib/internals/diff/#ComputableDAGs.Diff","page":"Diff","title":"ComputableDAGs.Diff","text":"Diff\n\nA named tuple representing a difference of added and removed nodes and edges on a DAG.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/diff/#Properties","page":"Diff","title":"Properties","text":"","category":"section"},{"location":"lib/internals/diff/#Base.length-Tuple{@NamedTuple{added_nodes::Vector{Node}, removed_nodes::Vector{Node}, added_edges::Vector{Edge}, removed_edges::Vector{Edge}, updated_children::Vector{Tuple{Node, AbstractTask}}}}","page":"Diff","title":"Base.length","text":"length(diff::Diff)\n\nReturn a named tuple of the lengths of the added/removed nodes/edges. The fields are .added_nodes, .added_edges, .removed_nodes and .removed_edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/diff/#Printing","page":"Diff","title":"Printing","text":"","category":"section"},{"location":"lib/internals/diff/#Base.show-Tuple{IO, @NamedTuple{added_nodes::Vector{Node}, removed_nodes::Vector{Node}, added_edges::Vector{Edge}, removed_edges::Vector{Edge}, updated_children::Vector{Tuple{Node, AbstractTask}}}}","page":"Diff","title":"Base.show","text":"show(io::IO, diff::Diff)\n\nPretty-print a Diff. Called via print, println and co.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Node","page":"Node","title":"Node","text":"","category":"section"},{"location":"lib/internals/node/#Type","page":"Node","title":"Type","text":"","category":"section"},{"location":"lib/internals/node/#ComputableDAGs.ComputeTaskNode","page":"Node","title":"ComputableDAGs.ComputeTaskNode","text":"ComputeTaskNode <: Node\n\nAny node that computes a result from inputs using an AbstractComputeTask.\n\nFields\n\n.task:            The node's compute task type. A concrete subtype of AbstractComputeTask.\n.parents:         A vector of the node's parents (i.e. nodes that depend on this one).\n.children:        A vector of tuples with the node's children (i.e. nodes that this one depends on) and their index, used to order the arguments for the AbstractComputeTask.\n.id:              The node's id. Improves the speed of comparisons and is used as a unique identifier.\n\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.DataTaskNode","page":"Node","title":"ComputableDAGs.DataTaskNode","text":"DataTaskNode <: Node\n\nAny node that transfers data and does no computation.\n\nFields\n\n.task:            The node's data task type. Usually DataTask.\n.parents:         A vector of the node's parents (i.e. nodes that depend on this one).\n.children:        A vector of tuples of the node's children (i.e. nodes that this one depends on) and their indices, indicating their order in the resulting function call passed to the task.\n.id:              The node's id. Improves the speed of comparisons and is used as a unique identifier.\n.name:            The name of this node for entry nodes into the graph (is_entry_node) to reliably assign the inputs to the correct nodes when executing.\n\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.Edge","page":"Node","title":"ComputableDAGs.Edge","text":"Edge\n\nType of an edge in the graph. Edges can only exist between a DataTaskNode and a ComputeTaskNode or vice versa, not between two of the same type of node.\n\nAn edge always points from child to parent: child = e.edge[1] and parent = e.edge[2]. Additionally, the Edgecontains theindex` which is used as the child's index in the parent node.\n\nThe child is the prerequisite node of the parent.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#ComputableDAGs.Node","page":"Node","title":"ComputableDAGs.Node","text":"Node\n\nThe abstract base type of every node.\n\nSee DataTaskNode, ComputeTaskNode and make_node.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/node/#Create","page":"Node","title":"Create","text":"","category":"section"},{"location":"lib/internals/node/#ComputableDAGs.make_edge","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::ComputeTaskNode, n2::DataTaskNode, index::Int)\n\nConstruct and return a new Edge pointing from n1 (child) to n2 (parent).\n\nThe index parameter is 0 by default and is passed to the parent node as argument index for its child.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_edge-2","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::Node, n2::Node, index::Int)\n\nFallback implementation of make_edge throwing an error. If you got this error it likely means you tried to construct an edge between two nodes of the same type.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_edge-3","page":"Node","title":"ComputableDAGs.make_edge","text":"make_edge(n1::DataTaskNode, n2::ComputeTaskNode)\n\nConstruct and return a new Edge pointing from n1 (child) to n2 (parent).\n\nThe index parameter is 0 by default and is passed to the parent node as argument index for its child.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_node","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractDataTask)\n\nConstruct and return a new DataTaskNode with the given task.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/node/#ComputableDAGs.make_node-Tuple{AbstractComputeTask}","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractComputeTask)\n\nConstruct and return a new ComputeTaskNode with the given task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.make_node-Tuple{AbstractTask}","page":"Node","title":"ComputableDAGs.make_node","text":"make_node(t::AbstractTask)\n\nFallback implementation of make_node for an AbstractTask, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Compare","page":"Node","title":"Compare","text":"","category":"section"},{"location":"lib/internals/node/#Base.:==-Tuple{Edge, Edge}","page":"Node","title":"Base.:==","text":"==(e1::Edge, e2::Edge)\n\nEquality comparison between two edges.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Tuple{Node, Node}","page":"Node","title":"Base.:==","text":"==(n1::Node, n2::Node)\n\nFallback equality comparison between two nodes. For equal node types, the more specific versions of this function will be called.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Union{Tuple{TaskType}, Tuple{ComputeTaskNode{TaskType}, ComputeTaskNode{TaskType}}} where TaskType<:AbstractComputeTask","page":"Node","title":"Base.:==","text":"==(n1::ComputeTaskNode, n2::ComputeTaskNode)\n\nEquality comparison between two ComputeTaskNodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.:==-Union{Tuple{TaskType}, Tuple{DataTaskNode{TaskType}, DataTaskNode{TaskType}}} where TaskType<:AbstractDataTask","page":"Node","title":"Base.:==","text":"==(n1::DataTaskNode, n2::DataTaskNode)\n\nEquality comparison between two DataTaskNodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Properties","page":"Node","title":"Properties","text":"","category":"section"},{"location":"lib/internals/node/#ComputableDAGs.children-Tuple{DAG, Union{ComputeTaskNode, DataTaskNode}}","page":"Node","title":"ComputableDAGs.children","text":"children(dag::DAG, node::Node)\n\nReturn node's children.\n\nA node's children are its prerequisite nodes, nodes that need to execute before the task of this node.\n\nA node's children are the nodes that must run before it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_child-Tuple{DAG, Node, Node}","page":"Node","title":"ComputableDAGs.is_child","text":"is_child(dag::DAG, potential_child::Node, node::Node)\n\nReturn whether the potential_child is a child of node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_entry_node-Tuple{Node}","page":"Node","title":"ComputableDAGs.is_entry_node","text":"is_entry_node(node::Node)\n\nReturn whether this node is an entry node in its graph, i.e., it has no children.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_exit_node-Tuple{Node}","page":"Node","title":"ComputableDAGs.is_exit_node","text":"is_exit_node(node::Node)\n\nReturn whether this node is an exit node of its graph, i.e., it has no parents.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_parent-Tuple{DAG, Node, Node}","page":"Node","title":"ComputableDAGs.is_parent","text":"is_parent(dag::DAG, potential_parent::Node, node::Node)\n\nReturn whether the potential_parent is a parent of node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.parents-Tuple{DAG, Union{ComputeTaskNode, DataTaskNode}}","page":"Node","title":"ComputableDAGs.parents","text":"parents(dag::DAG, node::Node)\n\nReturn the node's parents.\n\nA node's parents are its subsequent nodes, nodes that need this node to execute.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.partners-Tuple{DAG, Node, Set{Node}}","page":"Node","title":"ComputableDAGs.partners","text":"partners(dag::DAG, node::Node, set::Set{Node})\n\nAlternative version to partners(node::Node), avoiding allocation of a new set. Works on the given set and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.partners-Tuple{DAG, Node}","page":"Node","title":"ComputableDAGs.partners","text":"partners(dag::DAG, node::Node)\n\nReturn a vector of all partners of this node.\n\nA node's partners are all parents of any of its children. The result contains no duplicates and includes the node itself.\n\nnote: Note\nThis is very slow when there are multiple children with many parents. This is less of a problem in siblings(node::Node) because (depending on the model) there are no nodes with a large number of children, or only a single one.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.siblings-Tuple{DAG, Node}","page":"Node","title":"ComputableDAGs.siblings","text":"siblings(dag::DAG, node::Node)\n\nReturn a vector of all siblings of this node.\n\nA node's siblings are all children of any of its parents. The result contains no duplicates and includes the node itself.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.task-Union{Tuple{DataTaskNode{TaskType}}, Tuple{TaskType}} where TaskType<:AbstractDataTask","page":"Node","title":"ComputableDAGs.task","text":"task(node::Node)\n\nReturn the node's task.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Print","page":"Node","title":"Print","text":"","category":"section"},{"location":"lib/internals/node/#Base.show-Tuple{IO, Edge}","page":"Node","title":"Base.show","text":"show(io::IO, e::Edge)\n\nPrint a short string representation of the edge to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Base.show-Tuple{IO, Node}","page":"Node","title":"Base.show","text":"show(io::IO, n::Node)\n\nPrint a short string representation of the node to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.to_var_name-Tuple{Base.UUID}","page":"Node","title":"ComputableDAGs.to_var_name","text":"to_var_name(id::UUID)\n\nReturn the uuid as a string usable as a variable name in code generation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#Validate","page":"Node","title":"Validate","text":"","category":"section"},{"location":"lib/internals/node/#ComputableDAGs.is_valid-Tuple{DAG, ComputeTaskNode}","page":"Node","title":"ComputableDAGs.is_valid","text":"is_valid(dag::DAG, node::ComputeTaskNode)\n\nVerify that the given compute node is valid in the graph. Call with @assert or @test when testing or debugging.\n\nThis also calls is_valid_node(graph::DAG, node::Node).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_valid-Tuple{DAG, DataTaskNode}","page":"Node","title":"ComputableDAGs.is_valid","text":"is_valid(dag::DAG, node::DataTaskNode)\n\nVerify that the given compute node is valid in the graph. Call with @assert or @test when testing or debugging.\n\nThis also calls is_valid_node(graph::DAG, node::Node).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/node/#ComputableDAGs.is_valid_node-Tuple{DAG, Node}","page":"Node","title":"ComputableDAGs.is_valid_node","text":"is_valid_node(graph::DAG, node::Node)\n\nVerify that a given node is valid in the graph. Call like @test is_valid_node(g, n). Uses @assert to fail if something is invalid but also provide an error message.\n\nThis function is very performance intensive and should only be used when testing or debugging.\n\nSee also this function's specific versions for the concrete Node types is_valid(graph::DAG, node::ComputeTaskNode) and is_valid(graph::DAG, node::DataTaskNode).\n\n\n\n\n\n","category":"method"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The scope of problems this package intends to solve are computational problems whose structure is large and complex, but statically defined. For example, the Strassen matrix multiplication algorithm, implemented as a unit test in this package, has a static structure of slicing, matrix addition, and matrix multiplication, when the initial matrix size is known.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The rest of this page is a manual describing how to use this package. For a very simple example of a usage, you can refer to the Fibonacci implementation.","category":"page"},{"location":"manual/#1.-Building-a-DAG","page":"Manual","title":"1. Building a DAG","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The most central concept of this package is the Computable DAG. A DAG is a directed acyclic graph. For more information on the basics check out the wikipedia article. In the context of this package, every node in a CDAG represents a computation or a data transfer, and every edge represents a dependency between these nodes. For a valid CDAG, we can generate a function that computes all the compute nodes and produces the CDAGs result, hence, \"computable\".","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To create a DAG, some steps are necessary:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A problem defining struct needs to be defined. This does not have to inherit from any type and is completely free in its definition. It can contain information about the parameters of the problem, for example the matrix size in the Strassen matrix multiplication example.\nThe types of compute steps need to be defined. They are represented by AbstractComputeTasks and can be defined easily using the @compute_task macro.\nThe input nodes of the CDAG must have a way of reading their value from the input to the actually callable function later. For this, these input nodes are required to have a name and an input_expr must be defined to map from this input to the value of the node. To remove overhead from handling the strings at execution time, this is done by returning an expression that is later evaluated in the function.\nComputableDAGs.input_type needs to be implemented for the problem instance defined earlier, returning the expected type that the generated function will later be called with.\nImplement the ComputableDAGs.graph interface function, creating and returning the CDAG. The macros @assemble_dag, @add_entry, and @add_call can be used for this.","category":"page"},{"location":"manual/#2.-Working-with-the-CDAG","page":"Manual","title":"2. Working with the CDAG","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Once a CDAG has been created, it can be analyzed and optimized. For this, the concepts of Operations, AbstractEstimator, and AbstractOptimizers exist in this package. Operations can be pushed onto a CDAG, which applies it to the structure. Applied operations change the CDAG's structure, but not its computation. An estimator can estimate the required time (or some other metric, depending on its implementation) of a CDAG. These metrics may change by applying operations. Finally, these estimations and operations can be used together to optimize the CDAG.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If the intention is to use this package mostly as an overhead-free Dagger.jl alternative, this step may be skipped entirely.","category":"page"},{"location":"manual/#3.-Executing-the-CDAG","page":"Manual","title":"3. Executing the CDAG","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"When the CDAG is ready, it can be compiled for the machine you're running on.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nCurrently, as of version 0.2.4, only cpu_st (single threaded CPU) is working properly as machine definition.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, get_compute_function can be used to create a function that can be called on inputs. get_compute_function supports and in some cases requires keyword arguments, please refer to its documentation for more information.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Alternatively, GPU kernels can be generated by using kernel instead of get_compute_function. This is implemented for several GPU backends and produces a regular function for the given backend. Since RuntimeGeneratedFunctions.jl does not support GPU kernels at this time, this function will only be callable if the world age has been increased since its generation. Furthermore, the compute functions in the graph need to comply with all the normal requirements for GPU kernels, such as not calling dynamic functions.","category":"page"},{"location":"manual/#Application-repositories","page":"Manual","title":"Application repositories","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following repositories use this package productively:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"QEDFeynmanDiagrams.jl: Compute differential cross-sections of scattering processes in perturbative QED. Successor of QEDFeynman.jl below.\ndeprecated QEDFeynman: Compute differential cross-sections of scattering processes in ABC and QED models.","category":"page"},{"location":"lib/internals/properties/#Properties","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"lib/internals/properties/#Type","page":"Properties","title":"Type","text":"","category":"section"},{"location":"lib/internals/properties/#ComputableDAGs.GraphProperties","page":"Properties","title":"ComputableDAGs.GraphProperties","text":"GraphProperties\n\nRepresentation of a DAG's properties.\n\nFields:\n\ndata::Float64: The total data transfer.\ncompute_effort::Float64: The total compute effort.\ncompute_intensity::Float64: The compute intensity, will always equal compute_effort / data.\nnumber_of_nodes::Int: Number of Nodes.\nnumber_of_edges::Int: Number of Edges.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/properties/#Create","page":"Properties","title":"Create","text":"","category":"section"},{"location":"lib/internals/properties/#Utility","page":"Properties","title":"Utility","text":"","category":"section"},{"location":"lib/internals/properties/#Base.:+-Tuple{@NamedTuple{data::Float64, compute_effort::Float64, compute_intensity::Float64, number_of_nodes::Int64, number_of_edges::Int64}, @NamedTuple{data::Float64, compute_effort::Float64, compute_intensity::Float64, number_of_nodes::Int64, number_of_edges::Int64}}","page":"Properties","title":"Base.:+","text":"+(prop1::GraphProperties, prop2::GraphProperties)\n\nAdd prop1 and prop2 and return the result as a new GraphProperties. Also take care to keep consistent compute intensity.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/properties/#Base.:--Tuple{@NamedTuple{data::Float64, compute_effort::Float64, compute_intensity::Float64, number_of_nodes::Int64, number_of_edges::Int64}, @NamedTuple{data::Float64, compute_effort::Float64, compute_intensity::Float64, number_of_nodes::Int64, number_of_edges::Int64}}","page":"Properties","title":"Base.:-","text":"-(prop1::GraphProperties, prop2::GraphProperties)\n\nSubtract prop1 from prop2 and return the result as a new GraphProperties. Also take care to keep consistent compute intensity.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/properties/#Base.:--Tuple{@NamedTuple{data::Float64, compute_effort::Float64, compute_intensity::Float64, number_of_nodes::Int64, number_of_edges::Int64}}","page":"Properties","title":"Base.:-","text":"-(prop::GraphProperties)\n\nUnary negation of the graph properties. .compute_intensity will not be negated because .data and .compute_effort both are.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Operation","page":"Operation","title":"Operation","text":"","category":"section"},{"location":"lib/internals/operation/#Types","page":"Operation","title":"Types","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedNodeReduction","page":"Operation","title":"ComputableDAGs.AppliedNodeReduction","text":"AppliedNodeReduction <: AppliedOperation\n\nThe applied version of the NodeReduction.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedNodeSplit","page":"Operation","title":"ComputableDAGs.AppliedNodeSplit","text":"AppliedNodeSplit <: AppliedOperation\n\nThe applied version of the NodeSplit.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.AppliedOperation","page":"Operation","title":"ComputableDAGs.AppliedOperation","text":"AppliedOperation\n\nAn abstract base class for already applied operations. An applied operation can be reversed iff it is the last applied operation on the DAG. Every applied operation stores a Diff from when it was initially applied to be able to revert the operation.\n\nSee also: revert_operation!.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.NodeReduction","page":"Operation","title":"ComputableDAGs.NodeReduction","text":"NodeReduction <: Operation\n\nThe NodeReduction operation. Represents the reduction of two or more nodes with one another. Only one of the input nodes is kept, while all others are deleted and their parents are accumulated in the kept node's parents instead.\n\nAfter the node reduction is applied, the graph has length(nr.input) - 1 fewer nodes.\n\nRequirements for successful application\n\nA vector of nodes can be reduced if:\n\nAll nodes are in the graph.\nAll nodes have the same task type.\nAll nodes have the same set of children.\n\nis_valid_node_reduction_input can be used to @assert these requirements.\n\nSee also: can_reduce\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.NodeSplit","page":"Operation","title":"ComputableDAGs.NodeSplit","text":"NodeSplit <: Operation\n\nThe NodeSplit operation. Represents the split of its input node into one node for each of its parents. It is the reverse operation to the NodeReduction.\n\nRequirements for successful application\n\nA node can be split if:\n\nIt is in the graph.\nIt has at least 2 parents.\n\nis_valid_node_split_input can be used to @assert these requirements.\n\nSee also: can_split\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#ComputableDAGs.Operation","page":"Operation","title":"ComputableDAGs.Operation","text":"Operation\n\nAn abstract base class for operations. An operation can be applied to a DAG, changing its nodes and edges.\n\nPossible operations on a DAG can be retrieved using get_operations.\n\nSee also: push_operation!, pop_operation!\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/operation/#Find","page":"Operation","title":"Find","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.generate_operations-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.generate_operations","text":"generate_operations(dag::DAG)\n\nGenerate all possible operations on the graph. Used initially when the graph is freshly assembled or parsed. Uses multithreading for speedup.\n\nSafely inserts all the found operations into the graph and its nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.nr_insertion!-Tuple{DAG, Vector{NodeReduction}}","page":"Operation","title":"ComputableDAGs.nr_insertion!","text":"nr_insertion!(dag::DAG, operations::PossibleOperations, node_reductions::Vector{Vector{NodeReduction}})\n\nInsert the node reductions into the graph and the nodes' caches. Employs multithreading for speedup.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.ns_insertion!-Tuple{DAG, Vector{NodeSplit}}","page":"Operation","title":"ComputableDAGs.ns_insertion!","text":"ns_insertion!(operations::PossibleOperations, node_splits::Vector{Vector{NodeSplits}})\n\nInsert the node splits into the graph and the nodes' caches. Employs multithreading for speedup.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Apply","page":"Operation","title":"Apply","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.apply_all!-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.apply_all!","text":"apply_all!(dag::DAG)\n\nApply all unapplied operations in the DAG. Is automatically called in all functions that require the latest state of the DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, NodeReduction}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(dag::DAG, operation::NodeReduction)\n\nApply the given NodeReduction to the graph. Generic wrapper around node_reduction!.\n\nReturn an AppliedNodeReduction object generated from the graph's Diff.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, NodeSplit}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(dag::DAG, operation::NodeSplit)\n\nApply the given NodeSplit to the graph. Generic wrapper around node_split!.\n\nReturn an AppliedNodeSplit object generated from the graph's Diff.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.apply_operation!-Tuple{DAG, Operation}","page":"Operation","title":"ComputableDAGs.apply_operation!","text":"apply_operation!(dag::DAG, operation::Operation)\n\nFallback implementation of apply_operation! for unimplemented operation types, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.node_reduction!-Union{Tuple{NodeType}, Tuple{DAG, Vector{NodeType}}} where NodeType<:Node","page":"Operation","title":"ComputableDAGs.node_reduction!","text":"node_reduction!(dag::DAG, nodes::Vector{Node})\n\nReduce the given nodes together into one node, return the applied difference to the graph.\n\nFor details see NodeReduction.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.node_split!-Union{Tuple{NodeType}, Tuple{DAG, NodeType}} where NodeType<:Node","page":"Operation","title":"ComputableDAGs.node_split!","text":"node_split!(dag::DAG, n1::Node)\n\nSplit the given node into one node per parent, return the applied difference to the graph.\n\nFor details see NodeSplit.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_diff!-Tuple{DAG, @NamedTuple{added_nodes::Vector{Node}, removed_nodes::Vector{Node}, added_edges::Vector{Edge}, removed_edges::Vector{Edge}, updated_children::Vector{Tuple{Node, AbstractTask}}}}","page":"Operation","title":"ComputableDAGs.revert_diff!","text":"revert_diff!(dag::DAG, diff::Diff)\n\nRevert the given diff on the graph. Used to revert the individual AppliedOperations with revert_operation!.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, AppliedOperation}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(dag::DAG, operation::AppliedOperation)\n\nFallback implementation of operation reversion for unimplemented operation types, throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, ComputableDAGs.AppliedNodeReduction}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(dag::DAG, operation::AppliedNodeReduction)\n\nRevert the applied node reduction on the graph. Return the original NodeReduction operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.revert_operation!-Tuple{DAG, ComputableDAGs.AppliedNodeSplit}","page":"Operation","title":"ComputableDAGs.revert_operation!","text":"revert_operation!(dag::DAG, operation::AppliedNodeSplit)\n\nRevert the applied node split on the graph. Return the original NodeSplit operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Get","page":"Operation","title":"Get","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.get_operations-Tuple{DAG}","page":"Operation","title":"ComputableDAGs.get_operations","text":"get_operations(dag::DAG)\n\nReturn the PossibleOperations of the graph at the current state.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Clean","page":"Operation","title":"Clean","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.clean_node!-Tuple{DAG, Base.UUID}","page":"Operation","title":"ComputableDAGs.clean_node!","text":"clean_node!(dag::DAG, node_id::UUID)\n\nSort this node's parent and child sets, then find reductions and splits involving it. Needs to be called after the node was changed in some way.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.find_reductions!-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.find_reductions!","text":"find_reductions!(dag::DAG, node::Node)\n\nFind node reductions involving the given node. The function pushes the found NodeReduction (if any) everywhere it needs to be and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.find_splits!-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.find_splits!","text":"find_splits!(dag::DAG, node::Node)\n\nFind the node split of the given node. The function pushes the found NodeSplit (if any) everywhere it needs to be and returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Utility","page":"Operation","title":"Utility","text":"","category":"section"},{"location":"lib/internals/operation/#Base.:==-Tuple{NodeReduction, NodeReduction}","page":"Operation","title":"Base.:==","text":"==(op1::NodeReduction, op2::NodeReduction)\n\nEquality comparison between two node reductions. Two node reductions are considered equal when they have the same inputs.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.:==-Tuple{NodeSplit, NodeSplit}","page":"Operation","title":"Base.:==","text":"==(op1::NodeSplit, op2::NodeSplit)\n\nEquality comparison between two node splits. Two node splits are considered equal if they have the same input node.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.:==-Tuple{Operation, Operation}","page":"Operation","title":"Base.:==","text":"==(op1::Operation, op2::Operation)\n\nFallback implementation of operation equality. Return false. Actual comparisons are done by the overloads of same type operation comparisons.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.delete!-Tuple{PossibleOperations, NodeReduction}","page":"Operation","title":"Base.delete!","text":"delete!(operations::PossibleOperations, op::NodeReduction)\n\nDelete the given node reduction from the possible operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.delete!-Tuple{PossibleOperations, NodeSplit}","page":"Operation","title":"Base.delete!","text":"delete!(operations::PossibleOperations, op::NodeSplit)\n\nDelete the given node split from the possible operations.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.isempty-Tuple{PossibleOperations}","page":"Operation","title":"Base.isempty","text":"isempty(operations::PossibleOperations)\n\nReturn whether operations is empty, i.e. all of its fields are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.length-Tuple{PossibleOperations}","page":"Operation","title":"Base.length","text":"length(operations::PossibleOperations)\n\nReturn a named tuple with the number of each of the operation types as a named tuple. The fields are named the same as the PossibleOperations'.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.can_reduce-Tuple{Node, Node}","page":"Operation","title":"ComputableDAGs.can_reduce","text":"can_reduce(n1::Node, n2::Node)\n\nReturn whether the given two nodes can be reduced. See NodeReduction for the requirements.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.can_split-Tuple{Node}","page":"Operation","title":"ComputableDAGs.can_split","text":"can_split(n1::Node)\n\nReturn whether the given node can be split. See NodeSplit for the requirements.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Print","page":"Operation","title":"Print","text":"","category":"section"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, NodeReduction}","page":"Operation","title":"Base.show","text":"show(io::IO, op::NodeReduction)\n\nPrint a string representation of the node reduction to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, NodeSplit}","page":"Operation","title":"Base.show","text":"show(io::IO, op::NodeSplit)\n\nPrint a string representation of the node split to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Base.show-Tuple{IO, PossibleOperations}","page":"Operation","title":"Base.show","text":"show(io::IO, ops::PossibleOperations)\n\nPrint a string representation of the set of possible operations to io.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#Validate","page":"Operation","title":"Validate","text":"","category":"section"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid-Tuple{DAG, NodeReduction}","page":"Operation","title":"ComputableDAGs.is_valid","text":"is_valid(dag::DAG, nr::NodeReduction)\n\nAssert for a given NodeReduction whether it is a valid operation in the graph.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid-Tuple{DAG, NodeSplit}","page":"Operation","title":"ComputableDAGs.is_valid","text":"is_valid(dag::DAG, nr::NodeSplit)\n\nAssert for a given NodeSplit whether it is a valid operation in the graph.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid_node_reduction_input-Union{Tuple{NodeType}, Tuple{DAG, Vector{NodeType}}} where NodeType<:Node","page":"Operation","title":"ComputableDAGs.is_valid_node_reduction_input","text":"is_valid_node_reduction_input(dag::DAG, nodes::Vector{Node})\n\nAssert for a given node reduction input whether the nodes can be reduced. For the requirements of a node reduction see NodeReduction.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/operation/#ComputableDAGs.is_valid_node_split_input-Tuple{DAG, Node}","page":"Operation","title":"ComputableDAGs.is_valid_node_split_input","text":"is_valid_node_split_input(graph::DAG, n1::Node)\n\nAssert for a given node split input whether the node can be split. For the requirements of a node split see NodeSplit.\n\nIntended for use with @assert or @test.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"lib/internals/devices/#Interface","page":"Devices","title":"Interface","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs.AbstractDevice","page":"Devices","title":"ComputableDAGs.AbstractDevice","text":"AbstractDevice\n\nAbstract base type for every device, like GPUs, CPUs or any other compute devices. Every implementation needs to implement various functions.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.Machine","page":"Devices","title":"ComputableDAGs.Machine","text":"Machine\n\nA representation of a machine to execute on. Contains information about its architecture (CPUs, GPUs, maybe more). This representation can be used to make a more accurate cost prediction of a DAG state.\n\nSee also: Scheduler\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.DEVICE_TYPES","page":"Devices","title":"ComputableDAGs.DEVICE_TYPES","text":"DEVICE_TYPES::Vector{Type}\n\nGlobal vector of available and implemented device types. Each implementation of a AbstractDevice should add its concrete type to this vector.\n\nSee also: device_types, get_devices\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/devices/#ComputableDAGs.get_devices","page":"Devices","title":"ComputableDAGs.get_devices","text":"get_devices(t::Type{T}; verbose::Bool) where {T <: AbstractDevice}\n\nInterface function that must be implemented for every subtype of AbstractDevice. Returns a Vector{Type} of the devices for the given AbstractDevice Type available on the current machine.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.kernel","page":"Devices","title":"ComputableDAGs.kernel","text":"kernel(gpu_type::Type{<:AbstractGPU}, graph::DAG, instance)\n\nFor a GPU type, a DAG, and a problem instance, return an Expr containing a function of signature compute_<id>(input::<GPU>Vector, output::<GPU>Vector, n::Int64), which will return the result of the DAG computation of the input on the given output vector, intended for computation on GPUs. Currently, CUDAGPU and ROCmGPU are available if their respective package extensions are loaded.\n\nThe generated kernel function accepts its thread ID in only the x-dimension, and only as thread ID, not as block ID. The input and output should therefore be 1-dimensional vectors. For detailed information on GPU programming and the Julia packages, please refer to their respective documentations.\n\nA simple example call for a CUDA kernel might look like the following:\n\n@cuda threads = (32,) always_inline = true cuda_kernel!(cu_inputs, outputs, length(cu_inputs))\n\nnote: Note\nUnlike the standard get_compute_function to generate a callable function which returns a RuntimeGeneratedFunction, this returns an Expr that needs to be eval'd. This is a current limitation of RuntimeGeneratedFunctions.jl which currently cannot wrap GPU kernels. This might change in the future.\n\nSize limitation\n\nThe generated kernel does not use any internal parallelization, i.e., the DAG is compiled into a serialized function, processing each input in a single thread of the GPU. This means it can be heavily parallelized and use the GPU at 100% for sufficiently large input vectors (and assuming the function does not become IO limited etc.). However, it also means that there is a limit to how large the compiled function can be. If it gets too large, the compilation might fail, take too long to complete, the kernel might fail during execution if too much stack memory is required, or other similar problems. If this happens, your problem is likely too large to be compiled to a GPU kernel like this.\n\nCompute Requirements\n\nA GPU function has more restrictions on what can be computed than general functions running on the CPU. In Julia, there are mainly two important restrictions to consider:\n\nUsed data types must be stack allocatable, i.e., isbits(x) must be true for arguments and local variables used in ComputeTasks.\nFunction calls must not be dynamic. This means that type stability is required and the compiler must know in advance which method of a generic function to call. What this specifically entails may change with time and also differs between the different target GPU libraries. From experience, using the always_inline = true argument for @cuda calls can help with this.\n\nwarning: Warning\nThis feature is currently experimental. There are still some unresolved issues with the generated kernels.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#ComputableDAGs.measure_device!","page":"Devices","title":"ComputableDAGs.measure_device!","text":"measure_device!(device::AbstractDevice; verbose::Bool)\n\nInterface function that must be implemented for every subtype of AbstractDevice. Measures the compute speed of the given device and writes into it.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/devices/#Detect","page":"Devices","title":"Detect","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs.get_machine_info-Tuple{}","page":"Devices","title":"ComputableDAGs.get_machine_info","text":"get_machine_info(verbose::Bool)\n\nReturn the Machine currently running on. The parameter verbose defaults to true when interactive.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Measure","page":"Devices","title":"Measure","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs.measure_devices!-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.measure_devices!","text":"measure_devices(machine::Machine; verbose::Bool)\n\nMeasure FLOPS, RAM, cache sizes and what other properties can be extracted for the devices in the given machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.measure_transfer_rates!-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.measure_transfer_rates!","text":"measure_transfer_rates(machine::Machine; verbose::Bool)\n\nMeasure the transfer rates between devices in the machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#Implementations","page":"Devices","title":"Implementations","text":"","category":"section"},{"location":"lib/internals/devices/#General","page":"Devices","title":"General","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs._gen_let_statement-Tuple{Symbol}","page":"Devices","title":"ComputableDAGs._gen_let_statement","text":"_gen_let_statement(symbol::Symbol)\n\nReturn a let-Expr like <symbol> = <symbol>.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs._gen_local_init-Tuple{Symbol, Type}","page":"Devices","title":"ComputableDAGs._gen_local_init","text":"_gen_local_init(symbol::Symbol, type::Type)\n\nReturn an Expr that initializes the symbol in the local scope. The result looks like local <symbol>::<type>.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.cpu_st-Tuple{}","page":"Devices","title":"ComputableDAGs.cpu_st","text":"cpu_st()\n\nA function returning a Machine that only has a single thread of one CPU. It is the simplest machine definition possible and produces a simple function when used with get_compute_function.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.device_types-Tuple{}","page":"Devices","title":"ComputableDAGs.device_types","text":"device_types()\n\nReturn a vector of available and implemented device types.\n\nSee also: DEVICE_TYPES\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.entry_device-Tuple{Machine}","page":"Devices","title":"ComputableDAGs.entry_device","text":"entry_device(machine::Machine)\n\nReturn the \"entry\" device, i.e., the device that starts CPU threads and GPU kernels, and takes input values and returns the output value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.gen_access_expr-Union{Tuple{ComputableDAGs.FunctionCall{VAL_T}}, Tuple{VAL_T}} where VAL_T","page":"Devices","title":"ComputableDAGs.gen_access_expr","text":"gen_access_expr(fc::FunctionCall)\n\nReturn the\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.gen_local_init-Tuple{ComputableDAGs.FunctionCall}","page":"Devices","title":"ComputableDAGs.gen_local_init","text":"gen_local_init(fc::FunctionCall)\n\nDispatch from the given FunctionCall to the lower-level function _gen_local_init.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#ComputableDAGs.wrap_in_let_statement-Tuple{Any, Any}","page":"Devices","title":"ComputableDAGs.wrap_in_let_statement","text":"wrap_in_let_statement(expr, symbols)\n\nFor a given expression and a collection of symbols, generate a let statement that wraps the expression in a let statement with all the symbols, like let <symbol[1]>=<symbol[1]>, ..., <symbol[end]>=<symbol[end]> <expr> end\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#NUMA","page":"Devices","title":"NUMA","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs.NumaNode","page":"Devices","title":"ComputableDAGs.NumaNode","text":"NumaNode <: AbstractCPU\n\nRepresentation of a specific CPU that code can run on. Implements the AbstractDevice interface.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.get_devices-Union{Tuple{Type{T}}, Tuple{T}} where T<:NumaNode","page":"Devices","title":"ComputableDAGs.get_devices","text":"get_devices(deviceType::Type{T}; verbose::Bool) where {T <: NumaNode}\n\nReturn a Vector of NumaNodes available on the current machine. If verbose is true, print some additional information.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/devices/#GPUs","page":"Devices","title":"GPUs","text":"","category":"section"},{"location":"lib/internals/devices/#ComputableDAGs.CUDAGPU","page":"Devices","title":"ComputableDAGs.CUDAGPU","text":"CUDAGPU <: AbstractGPU\n\nRepresentation of a specific CUDA GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires CUDA to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.ROCmGPU","page":"Devices","title":"ComputableDAGs.ROCmGPU","text":"ROCmGPU <: AbstractGPU\n\nRepresentation of a specific AMD GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires AMDGPU to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/devices/#ComputableDAGs.oneAPIGPU","page":"Devices","title":"ComputableDAGs.oneAPIGPU","text":"oneAPIGPU <: AbstractGPU\n\nRepresentation of a specific Intel GPU that code can run on. Implements the AbstractDevice interface.\n\nnote: Note\nThis requires oneAPI to be loaded to be useful.\n\n\n\n\n\n","category":"type"},{"location":"examples/fibonacci/#Fibonacci","page":"Fibonacci","title":"Fibonacci","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"In this example, we want to calculate the n-th Fibonacci number using a DAG representation. The input is a tuple of two numbers, the definition of fib(0) and fib(1), to make it not just a constant Fibonacci evaluation.","category":"page"},{"location":"examples/fibonacci/#Model-Definition","page":"Fibonacci","title":"Model Definition","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"To define a model for your problem type, simply define a new struct. No specific type inheritance is necessary. An object of this will later represent a specific problem instance.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"using ComputableDAGs\n\nstruct Fibonacci\n    n::Int\nend","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"For this example, the n in the model definition is for the n-th Fibonacci number we want to calculate.","category":"page"},{"location":"examples/fibonacci/#Task-definitions","page":"Fibonacci","title":"Task definitions","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"For Fibonacci, we only need one type of compute task: An addition of two numbers to yield the next number. Compute tasks can be defined using the @compute_task macro. We provide the name, the compute effort, and the function to call.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"@compute_task Add 1 (+)","category":"page"},{"location":"examples/fibonacci/#Input-definitions","page":"Fibonacci","title":"Input definitions","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"For this model, we will need two different input nodes, fib(0) and fib(1), to base the rest of the DAG on. Input nodes are distinguished by name.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"To extract the correct numbers from the CDAG input, we have to provide an expression that does so by implementing input_expr, given the entry node's name. We'll use \"fib(0)\" and \"fib(1)\" as names.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"function ComputableDAGs.input_expr(::Fibonacci, name::String, input_symbol::Symbol)\n    return if (name == \"fib(0)\")\n        :($input_symbol[1])\n    elseif (name == \"fib(1)\")\n        :($input_symbol[2])\n    else\n        assert(false)\n    end\nend","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"For type inference when generating the function later, we also need to define the expected input type for our problem instance. As mentioned above, this is a Tuple{Int, Int} in our case.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"ComputableDAGs.input_type(::Fibonacci) = Tuple{Int, Int}","category":"page"},{"location":"examples/fibonacci/#Building-the-DAG","page":"Fibonacci","title":"Building the DAG","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"To be able to compute a DAG we first have to build it. This is done by implementing graph for our problem instance and returning a DAG. We can use several macros to make this simple: @assemble_dag, @add_call, @add_entry.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"function ComputableDAGs.graph(fib::Fibonacci)\n    @assert fib.n >= 2\n    return @assemble_dag begin\n        n1 = @add_entry \"fib(0)\" 1\n        n2 = @add_entry \"fib(1)\" 1\n\n        for _ in 3:fib.n\n            n3 = @add_call Add() 1 n1 n2\n            n1 = n2\n            n2 = n3\n        end\n    end\nend","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"In short, @assemble_dag begin ... end creates a scope in which @add_entry can add entry nodes and @add_call can add compute nodes. The whole expression then returns the DAG created in the scope. @add_entry takes two arguments: a node name, which is later passed to the input_expr implementation we defined above, and the expected data size of the output. This doesn't have to be in bytes, but it should be proportional across all data sizes in the DAG. @add_call takes the compute task that the compute node should execute. In our case, this is the Add task defined earlier. Note that this has to be an instance of the task object, not just the type name. The second argument is the expected output data size, as with the entry nodes. Finally, a list of all the input nodes to the compute task follows.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"The actual logic follows that of the Fibonacci sequence:","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"a_i = a_i-1 + a_i-2","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"To achieve this, in each iteration of the for-loop, n3 is created as a new node representing the addition of n1 and n2. Then, the variables are swapped such that n1 represents the next a_i-2 and n2 is the next a_i-1.","category":"page"},{"location":"examples/fibonacci/#Trying-it-out","page":"Fibonacci","title":"Trying it out","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"This is all we have to do to define the problem. Now we can use ComputableDAGs.jl to generate a callable function from this definition:","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"fib = Fibonacci(10)\ndag = graph(fib)\nf10 = get_compute_function(dag, fib, cpu_st(), @__MODULE__);\nnothing #hide","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"This function is now callable immediately:","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"using Test\n@test f10((0, 1)) == 34\n@test f10((5, 10)) == 445","category":"page"},{"location":"examples/fibonacci/#Jupyter-notebook","page":"Fibonacci","title":"Jupyter notebook","text":"","category":"section"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"You can download this file as a jupyter notebook here.","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"","category":"page"},{"location":"examples/fibonacci/","page":"Fibonacci","title":"Fibonacci","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/internals/scheduler/#Scheduler","page":"Scheduler","title":"Scheduler","text":"","category":"section"},{"location":"lib/internals/scheduler/#Interface","page":"Scheduler","title":"Interface","text":"","category":"section"},{"location":"lib/internals/scheduler/#ComputableDAGs.schedule_dag","page":"Scheduler","title":"ComputableDAGs.schedule_dag","text":"schedule_dag(::Scheduler, ::DAG, ::Machine)\n\nInterface functions that must be implemented for implementations of Scheduler.\n\nThe function assigns each ComputeTaskNode of the DAG to one of the devices in the given Machine and returns a Vector{Tuple{Node, Device}} representing a topological ordering.\n\nDataTaskNodes are not scheduled to devices since they do not compute. Instead, a data node transfers data from the AbstractDevice of their child to all AbstractDevices of its parents.\n\nThe produced schedule can be converted to FunctionCalls using lower.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/scheduler/#Types","page":"Scheduler","title":"Types","text":"","category":"section"},{"location":"lib/internals/scheduler/#ComputableDAGs.AbstractScheduler","page":"Scheduler","title":"ComputableDAGs.AbstractScheduler","text":"AbstractScheduler\n\nAbstract base type for scheduler implementations. The scheduler is used to assign each node to a device and create a topological ordering of tasks.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/scheduler/#Greedy","page":"Scheduler","title":"Greedy","text":"","category":"section"},{"location":"lib/internals/scheduler/#ComputableDAGs.GreedyScheduler","page":"Scheduler","title":"ComputableDAGs.GreedyScheduler","text":"GreedyScheduler\n\nA greedy implementation of a scheduler, creating a topological ordering of nodes and naively balancing them onto the different devices.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"lib/internals/models/#Interface","page":"Models","title":"Interface","text":"","category":"section"},{"location":"lib/internals/models/","page":"Models","title":"Models","text":"The interface that has to be implemented for a model to be usable is defined in src/models/interface.jl.","category":"page"},{"location":"lib/internals/models/#ComputableDAGs.graph","page":"Models","title":"ComputableDAGs.graph","text":"graph(problem_instance)\n\nGenerate the DAG for the given problem_instance. Every entry node (see get_entry_nodes) to the graph must have a name set. Implement input_expr to return a valid expression for each of those names.\n\nFor more details on the problem_instance, please refer to the documentation.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/models/#ComputableDAGs.input_expr","page":"Models","title":"ComputableDAGs.input_expr","text":"input_expr(problem_instance, name::String, input_symbol::Symbol)\n\nFor the given problem_instance, the entry node name, and the symbol of the problem input (where a variable of type input_type(...) will exist), return an Expr that gets that specific input value from the input symbol.\n\nFor more details on the problem_instance, please refer to the documentation.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/models/#ComputableDAGs.input_type","page":"Models","title":"ComputableDAGs.input_type","text":"input_type(problem_instance)\n\nReturn the input type for a specific problem_instance. This can be a specific type or a supertype for which all child types are expected to be implemented.\n\nFor more details on the problem_instance, please refer to the documentation.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"lib/internals/optimization/#Interface","page":"Optimization","title":"Interface","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"The interface that has to be implemented for an optimization algorithm.","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.AbstractOptimizer","page":"Optimization","title":"ComputableDAGs.AbstractOptimizer","text":"AbstractOptimizer\n\nAbstract base type for optimizer implementations.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#ComputableDAGs.fixpoint_reached-Tuple{AbstractOptimizer, DAG}","page":"Optimization","title":"ComputableDAGs.fixpoint_reached","text":"fixpoint_reached(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that can be implemented by optimization algorithms that can reach a fixpoint, returning as a Bool whether it has been reached. The default implementation returns false.\n\nSee also: optimize_to_fixpoint!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize!-Tuple{AbstractOptimizer, DAG, Int64}","page":"Optimization","title":"ComputableDAGs.optimize!","text":"optimize!(optimizer::AbstractOptimizer, graph::DAG, n::Int)\n\nFunction calling the given optimizer n times, muting the graph. Returns true if the requested number of operations has been applied, false if not, usually when a fixpoint of the algorithm has been reached.\n\nIf a more efficient method exists, this can be overloaded for a specific optimizer.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize_step!","page":"Optimization","title":"ComputableDAGs.optimize_step!","text":"optimize_step!(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that must be implemented by implementations of AbstractOptimizer. Returns true if an operations has been applied, false if not, usually when a fixpoint of the algorithm has been reached.\n\nIt should do one smallest logical step on the given DAG, muting the graph and, if necessary, the optimizer's state.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#ComputableDAGs.optimize_to_fixpoint!","page":"Optimization","title":"ComputableDAGs.optimize_to_fixpoint!","text":"optimize_to_fixpoint!(optimizer::AbstractOptimizer, graph::DAG)\n\nInterface function that can be implemented by optimization algorithms that can reach a fixpoint. The algorithm will be run until that fixpoint is reached, at which point fixpoint_reached should return true.\n\nA usual implementation might look like this:\n\n    function optimize_to_fixpoint!(optimizer::MyOptimizer, graph::DAG)\n        while !fixpoint_reached(optimizer, graph)\n            optimize_step!(optimizer, graph)\n        end\n        return nothing\n    end\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/optimization/#Random-Walk-Optimizer","page":"Optimization","title":"Random Walk Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a random walk algorithm.","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.RandomWalkOptimizer","page":"Optimization","title":"ComputableDAGs.RandomWalkOptimizer","text":"RandomWalkOptimizer\n\nAn optimizer that randomly pushes or pops operations. It doesn't optimize in any direction and is useful mainly for testing purposes.\n\nThis algorithm never reaches a fixpoint, so it does not implement optimize_to_fixpoint!.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Reduction-Optimizer","page":"Optimization","title":"Reduction Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a an optimizer that reduces as far as possible.","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.ReductionOptimizer","page":"Optimization","title":"ComputableDAGs.ReductionOptimizer","text":"ReductionOptimizer\n\nAn optimizer that simply applies an available NodeReduction on each step. It implements optimize_to_fixpoint!. The fixpoint is reached when there are no more possible NodeReductions in the graph.\n\nSee also: SplitOptimizer\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Split-Optimizer","page":"Optimization","title":"Split Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of an optimizer that splits as far as possible.","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.SplitOptimizer","page":"Optimization","title":"ComputableDAGs.SplitOptimizer","text":"SplitOptimizer\n\nAn optimizer that simply applies an available NodeSplit on each step. It implements optimize_to_fixpoint!. The fixpoint is reached when there are no more possible NodeSplits in the graph.\n\nSee also: ReductionOptimizer\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/optimization/#Greedy-Optimizer","page":"Optimization","title":"Greedy Optimizer","text":"","category":"section"},{"location":"lib/internals/optimization/","page":"Optimization","title":"Optimization","text":"Implementation of a greedy optimization algorithm.","category":"page"},{"location":"lib/internals/optimization/#ComputableDAGs.GreedyOptimizer","page":"Optimization","title":"ComputableDAGs.GreedyOptimizer","text":"GreedyOptimizer\n\nAn implementation of the greedy optimization algorithm, simply choosing the best next option evaluated with the given estimator.\n\nThe fixpoint is reached when any leftover operation would increase the graph's total cost according to the given estimator.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#Graph","page":"Graph","title":"Graph","text":"","category":"section"},{"location":"lib/internals/graph/#Type","page":"Graph","title":"Type","text":"","category":"section"},{"location":"lib/internals/graph/#ComputableDAGs.DAG","page":"Graph","title":"ComputableDAGs.DAG","text":"DAG\n\nThe representation of the graph as a set of Nodes.\n\nOperations can be applied on it using push_operation! and reverted using pop_operation! like a stack. To get the set of possible operations, use get_operations. The members of the object should not be manually accessed, instead always use the provided interface functions.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#ComputableDAGs.DAG-Tuple{}","page":"Graph","title":"ComputableDAGs.DAG","text":"DAG()\n\nConstruct and return an empty DAG.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.PossibleOperations","page":"Graph","title":"ComputableDAGs.PossibleOperations","text":"PossibleOperations\n\nA struct storing all possible operations on a DAG. To get the PossibleOperations on a DAG, use get_operations.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/graph/#ComputableDAGs.PossibleOperations-Tuple{}","page":"Graph","title":"ComputableDAGs.PossibleOperations","text":"PossibleOperations()\n\nConstruct and return an empty PossibleOperations object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Interface","page":"Graph","title":"Interface","text":"","category":"section"},{"location":"lib/internals/graph/#ComputableDAGs.can_pop-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.can_pop","text":"can_pop(dag::DAG)\n\nReturn true if pop_operation! is possible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.pop_operation!-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.pop_operation!","text":"pop_operation!(dag::DAG)\n\nRevert the latest applied operation on the graph.\n\nSee also: DAG, push_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.push_operation!-Tuple{DAG, Operation}","page":"Graph","title":"ComputableDAGs.push_operation!","text":"push_operation!(dag::DAG, operation::Operation)\n\nApply a new operation to the graph.\n\nSee also: DAG, pop_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.reset_graph!-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.reset_graph!","text":"reset_graph!(dag::DAG)\n\nReset the graph to its initial state with no operations applied.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Compare","page":"Graph","title":"Compare","text":"","category":"section"},{"location":"lib/internals/graph/#Base.in-Tuple{Edge, DAG}","page":"Graph","title":"Base.in","text":"in(edge::Edge, dag::DAG)\n\nCheck whether the edge is part of the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Base.in-Tuple{Node, DAG}","page":"Graph","title":"Base.in","text":"in(node::Node, dag::DAG)\n\nCheck whether the node is part of the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Mute","page":"Graph","title":"Mute","text":"","category":"section"},{"location":"lib/internals/graph/#ComputableDAGs._insert_edge!","page":"Graph","title":"ComputableDAGs._insert_edge!","text":"_insert_edge!(graph::DAG, node1::Node, node2::Node, index::Int=0; track = true, invalidate_cache = true)\n\nInsert the edge between node1 (child) and node2 (parent) into the graph. An optional integer index can be given. The arguments of the function call that this node compiles to will then be ordered by these indices.\n\nwarning: Warning\nFor creating new graphs, use the public version insert_edge! instead which uses the defaults false for the keywords.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _remove_node!, _remove_edge!\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/graph/#ComputableDAGs._insert_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs._insert_node!","text":"_insert_node!(dag::DAG, node::Node; track = true, invalidate_cache = true)\n\nInsert the node into the graph.\n\nwarning: Warning\nFor creating new graphs, use the public version insert_node! instead which uses the defaults false for the keywords.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\n\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _remove_node!, _insert_edge!, _remove_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs._remove_edge!-Tuple{DAG, Node, Node}","page":"Graph","title":"ComputableDAGs._remove_edge!","text":"_remove_edge!(dag::DAG, node1::Node, node2::Node; track = true, invalidate_cache = true)\n\nRemove the edge between node1 (child) and node2 (parent) into the graph. Returns the integer index of the removed edge.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _remove_node!, _insert_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs._remove_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs._remove_node!","text":"_remove_node!(dag::DAG, node::Node; track = true, invalidate_cache = true)\n\nRemove the node from the graph.\n\nKeyword Arguments\n\ntrack::Bool: Whether to add the changes to the DAG's Diff. Should be set false in parsing or graph creation functions for performance.\n\ninvalidate_cache::Bool: Whether to invalidate caches associated with the changes. Should also be turned off for graph creation or parsing.\n\nSee also: _insert_node!, _insert_edge!, _remove_edge!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_snapshot_diff-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_snapshot_diff","text":"get_snapshot_diff(dag::DAG)\n\nReturn the graph's Diff since last time this function was called. Then, clear the current diff.\n\nSee also: revert_diff!, AppliedOperation and revert_operation!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.insert_edge!","page":"Graph","title":"ComputableDAGs.insert_edge!","text":"insert_edge!(dag::DAG, node1::Node, node2::Node)\n\nInsert the edge between node1 (child) and node2 (parent) into the graph.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/graph/#ComputableDAGs.insert_node!-Tuple{DAG, Node}","page":"Graph","title":"ComputableDAGs.insert_node!","text":"insert_node!(dag::DAG, node::Node)\ninsert_node!(dag::DAG, task::AbstractTask, name::String=\"\")\n\nInsert the node into the graph or alternatively construct a node from the given task and insert it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Print","page":"Graph","title":"Print","text":"","category":"section"},{"location":"lib/internals/graph/#Base.show-Tuple{IO, DAG}","page":"Graph","title":"Base.show","text":"show(io::IO, dag::DAG)\n\nPrint the given graph to io. If there are too many nodes it will print only a summary of them.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.show_nodes-Tuple{IO, DAG}","page":"Graph","title":"ComputableDAGs.show_nodes","text":"show_nodes(io::IO, dag::DAG)\n\nPrint a graph's nodes. Should only be used for small graphs as it prints every node in a list.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Properties","page":"Graph","title":"Properties","text":"","category":"section"},{"location":"lib/internals/graph/#ComputableDAGs.get_entry_nodes-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_entry_nodes","text":"get_entry_nodes(dag::DAG)\n\nReturn a vector of the graph's entry nodes.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_exit_node-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_exit_node","text":"get_exit_node(dag::DAG)\n\nReturn the graph's exit node. This assumes the graph only has a single exit node. If the graph has multiple exit nodes, the one encountered first will be returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.get_properties-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.get_properties","text":"get_properties(dag::DAG)\n\nReturn the graph's GraphProperties.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.operation_stack_length-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.operation_stack_length","text":"operation_stack_length(dag::DAG)\n\nReturn the number of operations applied to the graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#Validate","page":"Graph","title":"Validate","text":"","category":"section"},{"location":"lib/internals/graph/#ComputableDAGs.is_connected-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.is_connected","text":"is_connected(dag::DAG)\n\nReturn whether the given graph is connected.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/graph/#ComputableDAGs.is_valid-Tuple{DAG}","page":"Graph","title":"ComputableDAGs.is_valid","text":"is_valid(dag::DAG)\n\nValidate the entire graph using asserts. Intended for testing with @assert is_valid(dag).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/estimator/#Estimation","page":"Estimation","title":"Estimation","text":"","category":"section"},{"location":"lib/internals/estimator/#Interface","page":"Estimation","title":"Interface","text":"","category":"section"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"The interface that has to be implemented for an estimator.","category":"page"},{"location":"lib/internals/estimator/#ComputableDAGs.AbstractEstimator","page":"Estimation","title":"ComputableDAGs.AbstractEstimator","text":"AbstractEstimator\n\nAbstract base type for an estimator. An estimator estimates the cost of a graph or the difference an operation applied to a graph will make to its cost.\n\nInterface functions are\n\ngraph_cost\noperation_effect\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/estimator/#ComputableDAGs.cost_type","page":"Estimation","title":"ComputableDAGs.cost_type","text":"cost_type(estimator::AbstractEstimator)\n\nInterface function returning a specific estimator's cost type, i.e., the type returned by its implementation of graph_cost and operation_effect.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/estimator/#ComputableDAGs.graph_cost","page":"Estimation","title":"ComputableDAGs.graph_cost","text":"graph_cost(estimator::AbstractEstimator, graph::DAG)\n\nGet the total estimated cost of the graph. The cost's data type can be chosen by the implementation, but must have a usable lessthan comparison operator (<), basic math operators (+, -) and an implementation of zero() and typemax().\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/estimator/#ComputableDAGs.operation_effect-Tuple{ComputableDAGs.AbstractEstimator, DAG, Operation}","page":"Estimation","title":"ComputableDAGs.operation_effect","text":"operation_effect(estimator::AbstractEstimator, graph::DAG, operation::Operation)\n\nGet the estimated effect on the cost of the graph, such that graph_cost(estimator, graph) + operation_effect(estimator, graph, operation) ~= graph_cost(estimator, graph_with_operation_applied). There is no hard requirement for this, but the better the estimate, the better an optimization algorithm will be.\n\nnote: Note\nThere is a default implementation of this function, applying the operation, calling graph_cost, then popping the operation again.It can be much faster to overload this function for a specific estimator and directly compute the effects from the operation if possible.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/estimator/#Global-Metric-Estimator","page":"Estimation","title":"Global Metric Estimator","text":"","category":"section"},{"location":"lib/internals/estimator/","page":"Estimation","title":"Estimation","text":"Implementation of a global metric estimator. It uses the graph properties compute effort, data transfer, and compute intensity.","category":"page"},{"location":"lib/internals/estimator/#ComputableDAGs.CDCost","page":"Estimation","title":"ComputableDAGs.CDCost","text":"CDCost\n\nRepresentation of a DAG's cost as estimated by the GlobalMetricEstimator.\n\nFields:\n\n.data: The total data transfer.\n.compute_effort: The total compute effort.\n\n\nFunctions:\n\ncompute_intensity(::CDCost): The compute intensity, equals .compute_effort / .data.\n\nnote: Note\nNote that the compute_intensity doesn't necessarily make sense in the context of only operation costs. It will still work as intended when adding/subtracting to/from a graph_cost estimate.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/estimator/#ComputableDAGs.GlobalMetricEstimator","page":"Estimation","title":"ComputableDAGs.GlobalMetricEstimator","text":"GlobalMetricEstimator <: AbstractEstimator\n\nA simple estimator that adds up each node's set compute_effort and data.\n\n\n\n\n\n","category":"type"},{"location":"#ComputableDAGs.jl","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"A domain-specific DAG-optimizer","category":"page"},{"location":"#General","page":"ComputableDAGs.jl","title":"General","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"This packages provides a way to represent large computations in a graph representation. Once such a graph is created, it can","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"be analyzed to extract properties such as total compute effort or data transfer necessary,\nbe optimized using optimization algorithms,\nbe scheduled on heterogeneous machines, making use of all available hardware\nbe compiled and executed within the same session of julia.","category":"page"},{"location":"#Requirements-for-use","page":"ComputableDAGs.jl","title":"Requirements for use","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"There are some hard requirements for this to be possible to a specific computation problem:","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The computation must be static, i.e., the structure of the graph may not dynamically change during the computation.\nAll data dependencies within the graph must be known in advance.\nThe overall computation must be separable into smaller parts with less than total interdependency.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Some more soft requirements exist for parts of the project to be useful:","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"For optimizations to be effective, the functions should have a predictable compute effort that can be known in advance.\nThe individual tasks should not be too small (ideally at least a few dozen FLOPs) because the compiler is smarter at optimizing very small functions than we can be.\nThe individual tasks should not be too large so the graph has a large enough number of nodes to allow for a larger optimization space.\nTasks should not have side-effects because the order and number of times a function is executed can not be relied upon.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"That being said, the package can still be useful even without using optimizations at all, simply as a way to schedule and distribute given work on a machine.","category":"page"},{"location":"#Comparison-to-Dagger.jl","page":"ComputableDAGs.jl","title":"Comparison to Dagger.jl","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Dagger.jl is a popular way of using scheduling work distributed on a machine, with complex dependencies in the form of a DAG. This makes it similar to the goals of this package. However, Dagger.jl schedules immediately as a piece of work is given. This has some effects:","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"It does allow the DAG to be dynamically built, it does not have to be known in advance, like with ComputableDAGs.jl\nIt adds some overhead at execution time for scheduling the tasks. This becomes worse the more work the scheduler has to do, for example when many cores exist, and when the tasks themselves are small and finish quickly.\nIt does not allow for optimizations ahead of execution, for example to prevent duplicate work.\nIt does not allow scheduling with the entire structure of the DAG already known.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Which package is better suited for a task certainly depends on the use-case.","category":"page"},{"location":"#Overview-of-the-Project-Structure","page":"ComputableDAGs.jl","title":"Overview of the Project Structure","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"(Image: Parts of the Project)","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The project consists of several parts that are designed to be mostly orthogonal interfaces, extendable with new implementations without having to change other parts of the code. For instructions on how to use the package and example implementations, refer to the manual, the examples, or the tests.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The Graph is the central part. It consists of Nodes and Edges. Nodes represent a Task, which is either a computation or a data transfer. Edges purely represent the dependencies between the nodes.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"A graph has to be generated first, which is done by defining a Model and providing some form of Generator for a specific problem instance of that model. This part is entirely up to the user. A generator might parse a file and generate a graph from that, or it may generate a basic graph by itself.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Estimators can be used to collect properties of the graph, for example the total compute effort defined by tasks.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"From any state of the graph, possible Operations can be generated. These represent topological changes to the graph which do not change the total computation. Operations can be applied and popped similar to a stack.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"The Optimizer interface then allows to use an estimator to push and pop operations to reduce the execution time.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Finally, the Scheduler can use Device information to generate the code.","category":"page"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"For detailed information on all the interfaces und functionality provided, please refer to the public documentation or the respective internals, as linked above.","category":"page"},{"location":"#Library-Outline","page":"ComputableDAGs.jl","title":"Library Outline","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/internals.md\"\n]","category":"page"},{"location":"#main-index","page":"ComputableDAGs.jl","title":"Index","text":"","category":"section"},{"location":"","page":"ComputableDAGs.jl","title":"ComputableDAGs.jl","text":"Pages = [\"lib/public.md\"]","category":"page"}]
}
